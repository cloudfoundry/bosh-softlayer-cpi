// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"bosh-softlayer-cpi/softlayer/common"
	bslcdisk "bosh-softlayer-cpi/softlayer/disk"
	bslcstem "bosh-softlayer-cpi/softlayer/stemcell"
	"sync"
)

type FakeVM struct {
	AttachDiskStub        func(bslcdisk.Disk) error
	attachDiskMutex       sync.RWMutex
	attachDiskArgsForCall []struct {
		arg1 bslcdisk.Disk
	}
	attachDiskReturns struct {
		result1 error
	}
	attachDiskReturnsOnCall map[int]struct {
		result1 error
	}
	ConfigureNetworksStub        func(common.Networks) error
	configureNetworksMutex       sync.RWMutex
	configureNetworksArgsForCall []struct {
		arg1 common.Networks
	}
	configureNetworksReturns struct {
		result1 error
	}
	configureNetworksReturnsOnCall map[int]struct {
		result1 error
	}
	ConfigureNetworks2Stub        func(common.Networks) error
	configureNetworks2Mutex       sync.RWMutex
	configureNetworks2ArgsForCall []struct {
		arg1 common.Networks
	}
	configureNetworks2Returns struct {
		result1 error
	}
	configureNetworks2ReturnsOnCall map[int]struct {
		result1 error
	}
	DetachDiskStub        func(bslcdisk.Disk) error
	detachDiskMutex       sync.RWMutex
	detachDiskArgsForCall []struct {
		arg1 bslcdisk.Disk
	}
	detachDiskReturns struct {
		result1 error
	}
	detachDiskReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteStub        func(agentId string) error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		agentId string
	}
	deleteReturns struct {
		result1 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 error
	}
	GetDataCenterIdStub        func() int
	getDataCenterIdMutex       sync.RWMutex
	getDataCenterIdArgsForCall []struct{}
	getDataCenterIdReturns     struct {
		result1 int
	}
	getDataCenterIdReturnsOnCall map[int]struct {
		result1 int
	}
	GetPrimaryIPStub        func() string
	getPrimaryIPMutex       sync.RWMutex
	getPrimaryIPArgsForCall []struct{}
	getPrimaryIPReturns     struct {
		result1 string
	}
	getPrimaryIPReturnsOnCall map[int]struct {
		result1 string
	}
	GetPrimaryBackendIPStub        func() string
	getPrimaryBackendIPMutex       sync.RWMutex
	getPrimaryBackendIPArgsForCall []struct{}
	getPrimaryBackendIPReturns     struct {
		result1 string
	}
	getPrimaryBackendIPReturnsOnCall map[int]struct {
		result1 string
	}
	GetRootPasswordStub        func() string
	getRootPasswordMutex       sync.RWMutex
	getRootPasswordArgsForCall []struct{}
	getRootPasswordReturns     struct {
		result1 string
	}
	getRootPasswordReturnsOnCall map[int]struct {
		result1 string
	}
	GetFullyQualifiedDomainNameStub        func() string
	getFullyQualifiedDomainNameMutex       sync.RWMutex
	getFullyQualifiedDomainNameArgsForCall []struct{}
	getFullyQualifiedDomainNameReturns     struct {
		result1 string
	}
	getFullyQualifiedDomainNameReturnsOnCall map[int]struct {
		result1 string
	}
	IDStub        func() int
	iDMutex       sync.RWMutex
	iDArgsForCall []struct{}
	iDReturns     struct {
		result1 int
	}
	iDReturnsOnCall map[int]struct {
		result1 int
	}
	RebootStub        func() error
	rebootMutex       sync.RWMutex
	rebootArgsForCall []struct{}
	rebootReturns     struct {
		result1 error
	}
	rebootReturnsOnCall map[int]struct {
		result1 error
	}
	ReloadOSStub        func(bslcstem.Stemcell) error
	reloadOSMutex       sync.RWMutex
	reloadOSArgsForCall []struct {
		arg1 bslcstem.Stemcell
	}
	reloadOSReturns struct {
		result1 error
	}
	reloadOSReturnsOnCall map[int]struct {
		result1 error
	}
	ReloadOSForBaremetalStub        func(string, string) error
	reloadOSForBaremetalMutex       sync.RWMutex
	reloadOSForBaremetalArgsForCall []struct {
		arg1 string
		arg2 string
	}
	reloadOSForBaremetalReturns struct {
		result1 error
	}
	reloadOSForBaremetalReturnsOnCall map[int]struct {
		result1 error
	}
	SetMetadataStub        func(common.VMMetadata) error
	setMetadataMutex       sync.RWMutex
	setMetadataArgsForCall []struct {
		arg1 common.VMMetadata
	}
	setMetadataReturns struct {
		result1 error
	}
	setMetadataReturnsOnCall map[int]struct {
		result1 error
	}
	SetVcapPasswordStub        func(string) error
	setVcapPasswordMutex       sync.RWMutex
	setVcapPasswordArgsForCall []struct {
		arg1 string
	}
	setVcapPasswordReturns struct {
		result1 error
	}
	setVcapPasswordReturnsOnCall map[int]struct {
		result1 error
	}
	SetAgentEnvServiceStub        func(common.AgentEnvService) error
	setAgentEnvServiceMutex       sync.RWMutex
	setAgentEnvServiceArgsForCall []struct {
		arg1 common.AgentEnvService
	}
	setAgentEnvServiceReturns struct {
		result1 error
	}
	setAgentEnvServiceReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateAgentEnvStub        func(common.AgentEnv) error
	updateAgentEnvMutex       sync.RWMutex
	updateAgentEnvArgsForCall []struct {
		arg1 common.AgentEnv
	}
	updateAgentEnvReturns struct {
		result1 error
	}
	updateAgentEnvReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteAgentEnvStub        func() error
	deleteAgentEnvMutex       sync.RWMutex
	deleteAgentEnvArgsForCall []struct{}
	deleteAgentEnvReturns     struct {
		result1 error
	}
	deleteAgentEnvReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeVM) AttachDisk(arg1 bslcdisk.Disk) error {
	fake.attachDiskMutex.Lock()
	ret, specificReturn := fake.attachDiskReturnsOnCall[len(fake.attachDiskArgsForCall)]
	fake.attachDiskArgsForCall = append(fake.attachDiskArgsForCall, struct {
		arg1 bslcdisk.Disk
	}{arg1})
	fake.recordInvocation("AttachDisk", []interface{}{arg1})
	fake.attachDiskMutex.Unlock()
	if fake.AttachDiskStub != nil {
		return fake.AttachDiskStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.attachDiskReturns.result1
}

func (fake *FakeVM) AttachDiskCallCount() int {
	fake.attachDiskMutex.RLock()
	defer fake.attachDiskMutex.RUnlock()
	return len(fake.attachDiskArgsForCall)
}

func (fake *FakeVM) AttachDiskArgsForCall(i int) bslcdisk.Disk {
	fake.attachDiskMutex.RLock()
	defer fake.attachDiskMutex.RUnlock()
	return fake.attachDiskArgsForCall[i].arg1
}

func (fake *FakeVM) AttachDiskReturns(result1 error) {
	fake.AttachDiskStub = nil
	fake.attachDiskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVM) AttachDiskReturnsOnCall(i int, result1 error) {
	fake.AttachDiskStub = nil
	if fake.attachDiskReturnsOnCall == nil {
		fake.attachDiskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.attachDiskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeVM) ConfigureNetworks(arg1 common.Networks) error {
	fake.configureNetworksMutex.Lock()
	ret, specificReturn := fake.configureNetworksReturnsOnCall[len(fake.configureNetworksArgsForCall)]
	fake.configureNetworksArgsForCall = append(fake.configureNetworksArgsForCall, struct {
		arg1 common.Networks
	}{arg1})
	fake.recordInvocation("ConfigureNetworks", []interface{}{arg1})
	fake.configureNetworksMutex.Unlock()
	if fake.ConfigureNetworksStub != nil {
		return fake.ConfigureNetworksStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.configureNetworksReturns.result1
}

func (fake *FakeVM) ConfigureNetworksCallCount() int {
	fake.configureNetworksMutex.RLock()
	defer fake.configureNetworksMutex.RUnlock()
	return len(fake.configureNetworksArgsForCall)
}

func (fake *FakeVM) ConfigureNetworksArgsForCall(i int) common.Networks {
	fake.configureNetworksMutex.RLock()
	defer fake.configureNetworksMutex.RUnlock()
	return fake.configureNetworksArgsForCall[i].arg1
}

func (fake *FakeVM) ConfigureNetworksReturns(result1 error) {
	fake.ConfigureNetworksStub = nil
	fake.configureNetworksReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVM) ConfigureNetworksReturnsOnCall(i int, result1 error) {
	fake.ConfigureNetworksStub = nil
	if fake.configureNetworksReturnsOnCall == nil {
		fake.configureNetworksReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.configureNetworksReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeVM) ConfigureNetworks2(arg1 common.Networks) error {
	fake.configureNetworks2Mutex.Lock()
	ret, specificReturn := fake.configureNetworks2ReturnsOnCall[len(fake.configureNetworks2ArgsForCall)]
	fake.configureNetworks2ArgsForCall = append(fake.configureNetworks2ArgsForCall, struct {
		arg1 common.Networks
	}{arg1})
	fake.recordInvocation("ConfigureNetworks2", []interface{}{arg1})
	fake.configureNetworks2Mutex.Unlock()
	if fake.ConfigureNetworks2Stub != nil {
		return fake.ConfigureNetworks2Stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.configureNetworks2Returns.result1
}

func (fake *FakeVM) ConfigureNetworks2CallCount() int {
	fake.configureNetworks2Mutex.RLock()
	defer fake.configureNetworks2Mutex.RUnlock()
	return len(fake.configureNetworks2ArgsForCall)
}

func (fake *FakeVM) ConfigureNetworks2ArgsForCall(i int) common.Networks {
	fake.configureNetworks2Mutex.RLock()
	defer fake.configureNetworks2Mutex.RUnlock()
	return fake.configureNetworks2ArgsForCall[i].arg1
}

func (fake *FakeVM) ConfigureNetworks2Returns(result1 error) {
	fake.ConfigureNetworks2Stub = nil
	fake.configureNetworks2Returns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVM) ConfigureNetworks2ReturnsOnCall(i int, result1 error) {
	fake.ConfigureNetworks2Stub = nil
	if fake.configureNetworks2ReturnsOnCall == nil {
		fake.configureNetworks2ReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.configureNetworks2ReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeVM) DetachDisk(arg1 bslcdisk.Disk) error {
	fake.detachDiskMutex.Lock()
	ret, specificReturn := fake.detachDiskReturnsOnCall[len(fake.detachDiskArgsForCall)]
	fake.detachDiskArgsForCall = append(fake.detachDiskArgsForCall, struct {
		arg1 bslcdisk.Disk
	}{arg1})
	fake.recordInvocation("DetachDisk", []interface{}{arg1})
	fake.detachDiskMutex.Unlock()
	if fake.DetachDiskStub != nil {
		return fake.DetachDiskStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.detachDiskReturns.result1
}

func (fake *FakeVM) DetachDiskCallCount() int {
	fake.detachDiskMutex.RLock()
	defer fake.detachDiskMutex.RUnlock()
	return len(fake.detachDiskArgsForCall)
}

func (fake *FakeVM) DetachDiskArgsForCall(i int) bslcdisk.Disk {
	fake.detachDiskMutex.RLock()
	defer fake.detachDiskMutex.RUnlock()
	return fake.detachDiskArgsForCall[i].arg1
}

func (fake *FakeVM) DetachDiskReturns(result1 error) {
	fake.DetachDiskStub = nil
	fake.detachDiskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVM) DetachDiskReturnsOnCall(i int, result1 error) {
	fake.DetachDiskStub = nil
	if fake.detachDiskReturnsOnCall == nil {
		fake.detachDiskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.detachDiskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeVM) Delete(agentId string) error {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		agentId string
	}{agentId})
	fake.recordInvocation("Delete", []interface{}{agentId})
	fake.deleteMutex.Unlock()
	if fake.DeleteStub != nil {
		return fake.DeleteStub(agentId)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteReturns.result1
}

func (fake *FakeVM) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeVM) DeleteArgsForCall(i int) string {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return fake.deleteArgsForCall[i].agentId
}

func (fake *FakeVM) DeleteReturns(result1 error) {
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVM) DeleteReturnsOnCall(i int, result1 error) {
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeVM) GetDataCenterId() int {
	fake.getDataCenterIdMutex.Lock()
	ret, specificReturn := fake.getDataCenterIdReturnsOnCall[len(fake.getDataCenterIdArgsForCall)]
	fake.getDataCenterIdArgsForCall = append(fake.getDataCenterIdArgsForCall, struct{}{})
	fake.recordInvocation("GetDataCenterId", []interface{}{})
	fake.getDataCenterIdMutex.Unlock()
	if fake.GetDataCenterIdStub != nil {
		return fake.GetDataCenterIdStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getDataCenterIdReturns.result1
}

func (fake *FakeVM) GetDataCenterIdCallCount() int {
	fake.getDataCenterIdMutex.RLock()
	defer fake.getDataCenterIdMutex.RUnlock()
	return len(fake.getDataCenterIdArgsForCall)
}

func (fake *FakeVM) GetDataCenterIdReturns(result1 int) {
	fake.GetDataCenterIdStub = nil
	fake.getDataCenterIdReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeVM) GetDataCenterIdReturnsOnCall(i int, result1 int) {
	fake.GetDataCenterIdStub = nil
	if fake.getDataCenterIdReturnsOnCall == nil {
		fake.getDataCenterIdReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.getDataCenterIdReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeVM) GetPrimaryIP() string {
	fake.getPrimaryIPMutex.Lock()
	ret, specificReturn := fake.getPrimaryIPReturnsOnCall[len(fake.getPrimaryIPArgsForCall)]
	fake.getPrimaryIPArgsForCall = append(fake.getPrimaryIPArgsForCall, struct{}{})
	fake.recordInvocation("GetPrimaryIP", []interface{}{})
	fake.getPrimaryIPMutex.Unlock()
	if fake.GetPrimaryIPStub != nil {
		return fake.GetPrimaryIPStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getPrimaryIPReturns.result1
}

func (fake *FakeVM) GetPrimaryIPCallCount() int {
	fake.getPrimaryIPMutex.RLock()
	defer fake.getPrimaryIPMutex.RUnlock()
	return len(fake.getPrimaryIPArgsForCall)
}

func (fake *FakeVM) GetPrimaryIPReturns(result1 string) {
	fake.GetPrimaryIPStub = nil
	fake.getPrimaryIPReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeVM) GetPrimaryIPReturnsOnCall(i int, result1 string) {
	fake.GetPrimaryIPStub = nil
	if fake.getPrimaryIPReturnsOnCall == nil {
		fake.getPrimaryIPReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getPrimaryIPReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeVM) GetPrimaryBackendIP() string {
	fake.getPrimaryBackendIPMutex.Lock()
	ret, specificReturn := fake.getPrimaryBackendIPReturnsOnCall[len(fake.getPrimaryBackendIPArgsForCall)]
	fake.getPrimaryBackendIPArgsForCall = append(fake.getPrimaryBackendIPArgsForCall, struct{}{})
	fake.recordInvocation("GetPrimaryBackendIP", []interface{}{})
	fake.getPrimaryBackendIPMutex.Unlock()
	if fake.GetPrimaryBackendIPStub != nil {
		return fake.GetPrimaryBackendIPStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getPrimaryBackendIPReturns.result1
}

func (fake *FakeVM) GetPrimaryBackendIPCallCount() int {
	fake.getPrimaryBackendIPMutex.RLock()
	defer fake.getPrimaryBackendIPMutex.RUnlock()
	return len(fake.getPrimaryBackendIPArgsForCall)
}

func (fake *FakeVM) GetPrimaryBackendIPReturns(result1 string) {
	fake.GetPrimaryBackendIPStub = nil
	fake.getPrimaryBackendIPReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeVM) GetPrimaryBackendIPReturnsOnCall(i int, result1 string) {
	fake.GetPrimaryBackendIPStub = nil
	if fake.getPrimaryBackendIPReturnsOnCall == nil {
		fake.getPrimaryBackendIPReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getPrimaryBackendIPReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeVM) GetRootPassword() string {
	fake.getRootPasswordMutex.Lock()
	ret, specificReturn := fake.getRootPasswordReturnsOnCall[len(fake.getRootPasswordArgsForCall)]
	fake.getRootPasswordArgsForCall = append(fake.getRootPasswordArgsForCall, struct{}{})
	fake.recordInvocation("GetRootPassword", []interface{}{})
	fake.getRootPasswordMutex.Unlock()
	if fake.GetRootPasswordStub != nil {
		return fake.GetRootPasswordStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getRootPasswordReturns.result1
}

func (fake *FakeVM) GetRootPasswordCallCount() int {
	fake.getRootPasswordMutex.RLock()
	defer fake.getRootPasswordMutex.RUnlock()
	return len(fake.getRootPasswordArgsForCall)
}

func (fake *FakeVM) GetRootPasswordReturns(result1 string) {
	fake.GetRootPasswordStub = nil
	fake.getRootPasswordReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeVM) GetRootPasswordReturnsOnCall(i int, result1 string) {
	fake.GetRootPasswordStub = nil
	if fake.getRootPasswordReturnsOnCall == nil {
		fake.getRootPasswordReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getRootPasswordReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeVM) GetFullyQualifiedDomainName() string {
	fake.getFullyQualifiedDomainNameMutex.Lock()
	ret, specificReturn := fake.getFullyQualifiedDomainNameReturnsOnCall[len(fake.getFullyQualifiedDomainNameArgsForCall)]
	fake.getFullyQualifiedDomainNameArgsForCall = append(fake.getFullyQualifiedDomainNameArgsForCall, struct{}{})
	fake.recordInvocation("GetFullyQualifiedDomainName", []interface{}{})
	fake.getFullyQualifiedDomainNameMutex.Unlock()
	if fake.GetFullyQualifiedDomainNameStub != nil {
		return fake.GetFullyQualifiedDomainNameStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getFullyQualifiedDomainNameReturns.result1
}

func (fake *FakeVM) GetFullyQualifiedDomainNameCallCount() int {
	fake.getFullyQualifiedDomainNameMutex.RLock()
	defer fake.getFullyQualifiedDomainNameMutex.RUnlock()
	return len(fake.getFullyQualifiedDomainNameArgsForCall)
}

func (fake *FakeVM) GetFullyQualifiedDomainNameReturns(result1 string) {
	fake.GetFullyQualifiedDomainNameStub = nil
	fake.getFullyQualifiedDomainNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeVM) GetFullyQualifiedDomainNameReturnsOnCall(i int, result1 string) {
	fake.GetFullyQualifiedDomainNameStub = nil
	if fake.getFullyQualifiedDomainNameReturnsOnCall == nil {
		fake.getFullyQualifiedDomainNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getFullyQualifiedDomainNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeVM) ID() int {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct{}{})
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if fake.IDStub != nil {
		return fake.IDStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.iDReturns.result1
}

func (fake *FakeVM) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *FakeVM) IDReturns(result1 int) {
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeVM) IDReturnsOnCall(i int, result1 int) {
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeVM) Reboot() error {
	fake.rebootMutex.Lock()
	ret, specificReturn := fake.rebootReturnsOnCall[len(fake.rebootArgsForCall)]
	fake.rebootArgsForCall = append(fake.rebootArgsForCall, struct{}{})
	fake.recordInvocation("Reboot", []interface{}{})
	fake.rebootMutex.Unlock()
	if fake.RebootStub != nil {
		return fake.RebootStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.rebootReturns.result1
}

func (fake *FakeVM) RebootCallCount() int {
	fake.rebootMutex.RLock()
	defer fake.rebootMutex.RUnlock()
	return len(fake.rebootArgsForCall)
}

func (fake *FakeVM) RebootReturns(result1 error) {
	fake.RebootStub = nil
	fake.rebootReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVM) RebootReturnsOnCall(i int, result1 error) {
	fake.RebootStub = nil
	if fake.rebootReturnsOnCall == nil {
		fake.rebootReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.rebootReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeVM) ReloadOS(arg1 bslcstem.Stemcell) error {
	fake.reloadOSMutex.Lock()
	ret, specificReturn := fake.reloadOSReturnsOnCall[len(fake.reloadOSArgsForCall)]
	fake.reloadOSArgsForCall = append(fake.reloadOSArgsForCall, struct {
		arg1 bslcstem.Stemcell
	}{arg1})
	fake.recordInvocation("ReloadOS", []interface{}{arg1})
	fake.reloadOSMutex.Unlock()
	if fake.ReloadOSStub != nil {
		return fake.ReloadOSStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.reloadOSReturns.result1
}

func (fake *FakeVM) ReloadOSCallCount() int {
	fake.reloadOSMutex.RLock()
	defer fake.reloadOSMutex.RUnlock()
	return len(fake.reloadOSArgsForCall)
}

func (fake *FakeVM) ReloadOSArgsForCall(i int) bslcstem.Stemcell {
	fake.reloadOSMutex.RLock()
	defer fake.reloadOSMutex.RUnlock()
	return fake.reloadOSArgsForCall[i].arg1
}

func (fake *FakeVM) ReloadOSReturns(result1 error) {
	fake.ReloadOSStub = nil
	fake.reloadOSReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVM) ReloadOSReturnsOnCall(i int, result1 error) {
	fake.ReloadOSStub = nil
	if fake.reloadOSReturnsOnCall == nil {
		fake.reloadOSReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.reloadOSReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeVM) ReloadOSForBaremetal(arg1 string, arg2 string) error {
	fake.reloadOSForBaremetalMutex.Lock()
	ret, specificReturn := fake.reloadOSForBaremetalReturnsOnCall[len(fake.reloadOSForBaremetalArgsForCall)]
	fake.reloadOSForBaremetalArgsForCall = append(fake.reloadOSForBaremetalArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("ReloadOSForBaremetal", []interface{}{arg1, arg2})
	fake.reloadOSForBaremetalMutex.Unlock()
	if fake.ReloadOSForBaremetalStub != nil {
		return fake.ReloadOSForBaremetalStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.reloadOSForBaremetalReturns.result1
}

func (fake *FakeVM) ReloadOSForBaremetalCallCount() int {
	fake.reloadOSForBaremetalMutex.RLock()
	defer fake.reloadOSForBaremetalMutex.RUnlock()
	return len(fake.reloadOSForBaremetalArgsForCall)
}

func (fake *FakeVM) ReloadOSForBaremetalArgsForCall(i int) (string, string) {
	fake.reloadOSForBaremetalMutex.RLock()
	defer fake.reloadOSForBaremetalMutex.RUnlock()
	return fake.reloadOSForBaremetalArgsForCall[i].arg1, fake.reloadOSForBaremetalArgsForCall[i].arg2
}

func (fake *FakeVM) ReloadOSForBaremetalReturns(result1 error) {
	fake.ReloadOSForBaremetalStub = nil
	fake.reloadOSForBaremetalReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVM) ReloadOSForBaremetalReturnsOnCall(i int, result1 error) {
	fake.ReloadOSForBaremetalStub = nil
	if fake.reloadOSForBaremetalReturnsOnCall == nil {
		fake.reloadOSForBaremetalReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.reloadOSForBaremetalReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeVM) SetMetadata(arg1 common.VMMetadata) error {
	fake.setMetadataMutex.Lock()
	ret, specificReturn := fake.setMetadataReturnsOnCall[len(fake.setMetadataArgsForCall)]
	fake.setMetadataArgsForCall = append(fake.setMetadataArgsForCall, struct {
		arg1 common.VMMetadata
	}{arg1})
	fake.recordInvocation("SetMetadata", []interface{}{arg1})
	fake.setMetadataMutex.Unlock()
	if fake.SetMetadataStub != nil {
		return fake.SetMetadataStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setMetadataReturns.result1
}

func (fake *FakeVM) SetMetadataCallCount() int {
	fake.setMetadataMutex.RLock()
	defer fake.setMetadataMutex.RUnlock()
	return len(fake.setMetadataArgsForCall)
}

func (fake *FakeVM) SetMetadataArgsForCall(i int) common.VMMetadata {
	fake.setMetadataMutex.RLock()
	defer fake.setMetadataMutex.RUnlock()
	return fake.setMetadataArgsForCall[i].arg1
}

func (fake *FakeVM) SetMetadataReturns(result1 error) {
	fake.SetMetadataStub = nil
	fake.setMetadataReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVM) SetMetadataReturnsOnCall(i int, result1 error) {
	fake.SetMetadataStub = nil
	if fake.setMetadataReturnsOnCall == nil {
		fake.setMetadataReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setMetadataReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeVM) SetVcapPassword(arg1 string) error {
	fake.setVcapPasswordMutex.Lock()
	ret, specificReturn := fake.setVcapPasswordReturnsOnCall[len(fake.setVcapPasswordArgsForCall)]
	fake.setVcapPasswordArgsForCall = append(fake.setVcapPasswordArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("SetVcapPassword", []interface{}{arg1})
	fake.setVcapPasswordMutex.Unlock()
	if fake.SetVcapPasswordStub != nil {
		return fake.SetVcapPasswordStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setVcapPasswordReturns.result1
}

func (fake *FakeVM) SetVcapPasswordCallCount() int {
	fake.setVcapPasswordMutex.RLock()
	defer fake.setVcapPasswordMutex.RUnlock()
	return len(fake.setVcapPasswordArgsForCall)
}

func (fake *FakeVM) SetVcapPasswordArgsForCall(i int) string {
	fake.setVcapPasswordMutex.RLock()
	defer fake.setVcapPasswordMutex.RUnlock()
	return fake.setVcapPasswordArgsForCall[i].arg1
}

func (fake *FakeVM) SetVcapPasswordReturns(result1 error) {
	fake.SetVcapPasswordStub = nil
	fake.setVcapPasswordReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVM) SetVcapPasswordReturnsOnCall(i int, result1 error) {
	fake.SetVcapPasswordStub = nil
	if fake.setVcapPasswordReturnsOnCall == nil {
		fake.setVcapPasswordReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setVcapPasswordReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeVM) SetAgentEnvService(arg1 common.AgentEnvService) error {
	fake.setAgentEnvServiceMutex.Lock()
	ret, specificReturn := fake.setAgentEnvServiceReturnsOnCall[len(fake.setAgentEnvServiceArgsForCall)]
	fake.setAgentEnvServiceArgsForCall = append(fake.setAgentEnvServiceArgsForCall, struct {
		arg1 common.AgentEnvService
	}{arg1})
	fake.recordInvocation("SetAgentEnvService", []interface{}{arg1})
	fake.setAgentEnvServiceMutex.Unlock()
	if fake.SetAgentEnvServiceStub != nil {
		return fake.SetAgentEnvServiceStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setAgentEnvServiceReturns.result1
}

func (fake *FakeVM) SetAgentEnvServiceCallCount() int {
	fake.setAgentEnvServiceMutex.RLock()
	defer fake.setAgentEnvServiceMutex.RUnlock()
	return len(fake.setAgentEnvServiceArgsForCall)
}

func (fake *FakeVM) SetAgentEnvServiceArgsForCall(i int) common.AgentEnvService {
	fake.setAgentEnvServiceMutex.RLock()
	defer fake.setAgentEnvServiceMutex.RUnlock()
	return fake.setAgentEnvServiceArgsForCall[i].arg1
}

func (fake *FakeVM) SetAgentEnvServiceReturns(result1 error) {
	fake.SetAgentEnvServiceStub = nil
	fake.setAgentEnvServiceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVM) SetAgentEnvServiceReturnsOnCall(i int, result1 error) {
	fake.SetAgentEnvServiceStub = nil
	if fake.setAgentEnvServiceReturnsOnCall == nil {
		fake.setAgentEnvServiceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setAgentEnvServiceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeVM) UpdateAgentEnv(arg1 common.AgentEnv) error {
	fake.updateAgentEnvMutex.Lock()
	ret, specificReturn := fake.updateAgentEnvReturnsOnCall[len(fake.updateAgentEnvArgsForCall)]
	fake.updateAgentEnvArgsForCall = append(fake.updateAgentEnvArgsForCall, struct {
		arg1 common.AgentEnv
	}{arg1})
	fake.recordInvocation("UpdateAgentEnv", []interface{}{arg1})
	fake.updateAgentEnvMutex.Unlock()
	if fake.UpdateAgentEnvStub != nil {
		return fake.UpdateAgentEnvStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.updateAgentEnvReturns.result1
}

func (fake *FakeVM) UpdateAgentEnvCallCount() int {
	fake.updateAgentEnvMutex.RLock()
	defer fake.updateAgentEnvMutex.RUnlock()
	return len(fake.updateAgentEnvArgsForCall)
}

func (fake *FakeVM) UpdateAgentEnvArgsForCall(i int) common.AgentEnv {
	fake.updateAgentEnvMutex.RLock()
	defer fake.updateAgentEnvMutex.RUnlock()
	return fake.updateAgentEnvArgsForCall[i].arg1
}

func (fake *FakeVM) UpdateAgentEnvReturns(result1 error) {
	fake.UpdateAgentEnvStub = nil
	fake.updateAgentEnvReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVM) UpdateAgentEnvReturnsOnCall(i int, result1 error) {
	fake.UpdateAgentEnvStub = nil
	if fake.updateAgentEnvReturnsOnCall == nil {
		fake.updateAgentEnvReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateAgentEnvReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeVM) DeleteAgentEnv() error {
	fake.deleteAgentEnvMutex.Lock()
	ret, specificReturn := fake.deleteAgentEnvReturnsOnCall[len(fake.deleteAgentEnvArgsForCall)]
	fake.deleteAgentEnvArgsForCall = append(fake.deleteAgentEnvArgsForCall, struct{}{})
	fake.recordInvocation("DeleteAgentEnv", []interface{}{})
	fake.deleteAgentEnvMutex.Unlock()
	if fake.DeleteAgentEnvStub != nil {
		return fake.DeleteAgentEnvStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteAgentEnvReturns.result1
}

func (fake *FakeVM) DeleteAgentEnvCallCount() int {
	fake.deleteAgentEnvMutex.RLock()
	defer fake.deleteAgentEnvMutex.RUnlock()
	return len(fake.deleteAgentEnvArgsForCall)
}

func (fake *FakeVM) DeleteAgentEnvReturns(result1 error) {
	fake.DeleteAgentEnvStub = nil
	fake.deleteAgentEnvReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVM) DeleteAgentEnvReturnsOnCall(i int, result1 error) {
	fake.DeleteAgentEnvStub = nil
	if fake.deleteAgentEnvReturnsOnCall == nil {
		fake.deleteAgentEnvReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteAgentEnvReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeVM) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.attachDiskMutex.RLock()
	defer fake.attachDiskMutex.RUnlock()
	fake.configureNetworksMutex.RLock()
	defer fake.configureNetworksMutex.RUnlock()
	fake.configureNetworks2Mutex.RLock()
	defer fake.configureNetworks2Mutex.RUnlock()
	fake.detachDiskMutex.RLock()
	defer fake.detachDiskMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.getDataCenterIdMutex.RLock()
	defer fake.getDataCenterIdMutex.RUnlock()
	fake.getPrimaryIPMutex.RLock()
	defer fake.getPrimaryIPMutex.RUnlock()
	fake.getPrimaryBackendIPMutex.RLock()
	defer fake.getPrimaryBackendIPMutex.RUnlock()
	fake.getRootPasswordMutex.RLock()
	defer fake.getRootPasswordMutex.RUnlock()
	fake.getFullyQualifiedDomainNameMutex.RLock()
	defer fake.getFullyQualifiedDomainNameMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.rebootMutex.RLock()
	defer fake.rebootMutex.RUnlock()
	fake.reloadOSMutex.RLock()
	defer fake.reloadOSMutex.RUnlock()
	fake.reloadOSForBaremetalMutex.RLock()
	defer fake.reloadOSForBaremetalMutex.RUnlock()
	fake.setMetadataMutex.RLock()
	defer fake.setMetadataMutex.RUnlock()
	fake.setVcapPasswordMutex.RLock()
	defer fake.setVcapPasswordMutex.RUnlock()
	fake.setAgentEnvServiceMutex.RLock()
	defer fake.setAgentEnvServiceMutex.RUnlock()
	fake.updateAgentEnvMutex.RLock()
	defer fake.updateAgentEnvMutex.RUnlock()
	fake.deleteAgentEnvMutex.RLock()
	defer fake.deleteAgentEnvMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeVM) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ common.VM = new(FakeVM)
