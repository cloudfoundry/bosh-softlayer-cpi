// This file was generated by counterfeiter
package fakes

import (
	"bosh-softlayer-cpi/softlayer/client"
	"sync"
	"time"

	"github.com/softlayer/softlayer-go/datatypes"
)

type FakeClient struct {
	CancelInstanceStub        func(id int) error
	cancelInstanceMutex       sync.RWMutex
	cancelInstanceArgsForCall []struct {
		id int
	}
	cancelInstanceReturns struct {
		result1 error
	}
	cancelInstanceReturnsOnCall map[int]struct {
		result1 error
	}
	CreateInstanceStub        func(template *datatypes.Virtual_Guest) (*datatypes.Virtual_Guest, error)
	createInstanceMutex       sync.RWMutex
	createInstanceArgsForCall []struct {
		template *datatypes.Virtual_Guest
	}
	createInstanceReturns struct {
		result1 *datatypes.Virtual_Guest
		result2 error
	}
	createInstanceReturnsOnCall map[int]struct {
		result1 *datatypes.Virtual_Guest
		result2 error
	}
	EditInstanceStub        func(id int, template *datatypes.Virtual_Guest) (bool, error)
	editInstanceMutex       sync.RWMutex
	editInstanceArgsForCall []struct {
		id       int
		template *datatypes.Virtual_Guest
	}
	editInstanceReturns struct {
		result1 bool
		result2 error
	}
	editInstanceReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	GetInstanceStub        func(id int, mask string) (*datatypes.Virtual_Guest, bool, error)
	getInstanceMutex       sync.RWMutex
	getInstanceArgsForCall []struct {
		id   int
		mask string
	}
	getInstanceReturns struct {
		result1 *datatypes.Virtual_Guest
		result2 bool
		result3 error
	}
	getInstanceReturnsOnCall map[int]struct {
		result1 *datatypes.Virtual_Guest
		result2 bool
		result3 error
	}
	GetInstanceByPrimaryBackendIpAddressStub        func(ip string) (*datatypes.Virtual_Guest, bool, error)
	getInstanceByPrimaryBackendIpAddressMutex       sync.RWMutex
	getInstanceByPrimaryBackendIpAddressArgsForCall []struct {
		ip string
	}
	getInstanceByPrimaryBackendIpAddressReturns struct {
		result1 *datatypes.Virtual_Guest
		result2 bool
		result3 error
	}
	getInstanceByPrimaryBackendIpAddressReturnsOnCall map[int]struct {
		result1 *datatypes.Virtual_Guest
		result2 bool
		result3 error
	}
	GetInstanceByPrimaryIpAddressStub        func(ip string) (*datatypes.Virtual_Guest, bool, error)
	getInstanceByPrimaryIpAddressMutex       sync.RWMutex
	getInstanceByPrimaryIpAddressArgsForCall []struct {
		ip string
	}
	getInstanceByPrimaryIpAddressReturns struct {
		result1 *datatypes.Virtual_Guest
		result2 bool
		result3 error
	}
	getInstanceByPrimaryIpAddressReturnsOnCall map[int]struct {
		result1 *datatypes.Virtual_Guest
		result2 bool
		result3 error
	}
	RebootInstanceStub        func(id int, soft bool, hard bool) error
	rebootInstanceMutex       sync.RWMutex
	rebootInstanceArgsForCall []struct {
		id   int
		soft bool
		hard bool
	}
	rebootInstanceReturns struct {
		result1 error
	}
	rebootInstanceReturnsOnCall map[int]struct {
		result1 error
	}
	ReloadInstanceStub        func(id int, stemcellId int, sshKeyIds []int, hostname string, domain string) error
	reloadInstanceMutex       sync.RWMutex
	reloadInstanceArgsForCall []struct {
		id         int
		stemcellId int
		sshKeyIds  []int
		hostname   string
		domain     string
	}
	reloadInstanceReturns struct {
		result1 error
	}
	reloadInstanceReturnsOnCall map[int]struct {
		result1 error
	}
	UpgradeInstanceConfigStub        func(id int, cpu int, memory int, network int, privateCPU bool) error
	upgradeInstanceConfigMutex       sync.RWMutex
	upgradeInstanceConfigArgsForCall []struct {
		id         int
		cpu        int
		memory     int
		network    int
		privateCPU bool
	}
	upgradeInstanceConfigReturns struct {
		result1 error
	}
	upgradeInstanceConfigReturnsOnCall map[int]struct {
		result1 error
	}
	UpgradeInstanceStub        func(id int, cpu int, memory int, network int, privateCPU bool, additional_diskSize int) (*datatypes.Container_Product_Order_Receipt, error)
	upgradeInstanceMutex       sync.RWMutex
	upgradeInstanceArgsForCall []struct {
		id                  int
		cpu                 int
		memory              int
		network             int
		privateCPU          bool
		additional_diskSize int
	}
	upgradeInstanceReturns struct {
		result1 *datatypes.Container_Product_Order_Receipt
		result2 error
	}
	upgradeInstanceReturnsOnCall map[int]struct {
		result1 *datatypes.Container_Product_Order_Receipt
		result2 error
	}
	WaitInstanceUntilReadyStub        func(id int, until time.Time) error
	waitInstanceUntilReadyMutex       sync.RWMutex
	waitInstanceUntilReadyArgsForCall []struct {
		id    int
		until time.Time
	}
	waitInstanceUntilReadyReturns struct {
		result1 error
	}
	waitInstanceUntilReadyReturnsOnCall map[int]struct {
		result1 error
	}
	WaitInstanceHasActiveTransactionStub        func(id int, until time.Time) error
	waitInstanceHasActiveTransactionMutex       sync.RWMutex
	waitInstanceHasActiveTransactionArgsForCall []struct {
		id    int
		until time.Time
	}
	waitInstanceHasActiveTransactionReturns struct {
		result1 error
	}
	waitInstanceHasActiveTransactionReturnsOnCall map[int]struct {
		result1 error
	}
	WaitInstanceHasNoneActiveTransactionStub        func(id int, until time.Time) error
	waitInstanceHasNoneActiveTransactionMutex       sync.RWMutex
	waitInstanceHasNoneActiveTransactionArgsForCall []struct {
		id    int
		until time.Time
	}
	waitInstanceHasNoneActiveTransactionReturns struct {
		result1 error
	}
	waitInstanceHasNoneActiveTransactionReturnsOnCall map[int]struct {
		result1 error
	}
	WaitVolumeProvisioningWithOrderIdStub        func(orderId int, until time.Time) (*datatypes.Network_Storage, error)
	waitVolumeProvisioningWithOrderIdMutex       sync.RWMutex
	waitVolumeProvisioningWithOrderIdArgsForCall []struct {
		orderId int
		until   time.Time
	}
	waitVolumeProvisioningWithOrderIdReturns struct {
		result1 *datatypes.Network_Storage
		result2 error
	}
	waitVolumeProvisioningWithOrderIdReturnsOnCall map[int]struct {
		result1 *datatypes.Network_Storage
		result2 error
	}
	SetTagsStub        func(id int, tags string) (bool, error)
	setTagsMutex       sync.RWMutex
	setTagsArgsForCall []struct {
		id   int
		tags string
	}
	setTagsReturns struct {
		result1 bool
		result2 error
	}
	setTagsReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	AttachSecondDiskToInstanceStub        func(id int, diskSize int) error
	attachSecondDiskToInstanceMutex       sync.RWMutex
	attachSecondDiskToInstanceArgsForCall []struct {
		id       int
		diskSize int
	}
	attachSecondDiskToInstanceReturns struct {
		result1 error
	}
	attachSecondDiskToInstanceReturnsOnCall map[int]struct {
		result1 error
	}
	GetInstanceAllowedHostStub        func(id int) (*datatypes.Network_Storage_Allowed_Host, bool, error)
	getInstanceAllowedHostMutex       sync.RWMutex
	getInstanceAllowedHostArgsForCall []struct {
		id int
	}
	getInstanceAllowedHostReturns struct {
		result1 *datatypes.Network_Storage_Allowed_Host
		result2 bool
		result3 error
	}
	getInstanceAllowedHostReturnsOnCall map[int]struct {
		result1 *datatypes.Network_Storage_Allowed_Host
		result2 bool
		result3 error
	}
	AuthorizeHostToVolumeStub        func(instance *datatypes.Virtual_Guest, volumeId int, until time.Time) (bool, error)
	authorizeHostToVolumeMutex       sync.RWMutex
	authorizeHostToVolumeArgsForCall []struct {
		instance *datatypes.Virtual_Guest
		volumeId int
		until    time.Time
	}
	authorizeHostToVolumeReturns struct {
		result1 bool
		result2 error
	}
	authorizeHostToVolumeReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	DeauthorizeHostToVolumeStub        func(instance *datatypes.Virtual_Guest, volumeId int, until time.Time) (bool, error)
	deauthorizeHostToVolumeMutex       sync.RWMutex
	deauthorizeHostToVolumeArgsForCall []struct {
		instance *datatypes.Virtual_Guest
		volumeId int
		until    time.Time
	}
	deauthorizeHostToVolumeReturns struct {
		result1 bool
		result2 error
	}
	deauthorizeHostToVolumeReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	CreateVolumeStub        func(location string, size int, iops int) (*datatypes.Network_Storage, error)
	createVolumeMutex       sync.RWMutex
	createVolumeArgsForCall []struct {
		location string
		size     int
		iops     int
	}
	createVolumeReturns struct {
		result1 *datatypes.Network_Storage
		result2 error
	}
	createVolumeReturnsOnCall map[int]struct {
		result1 *datatypes.Network_Storage
		result2 error
	}
	OrderBlockVolumeStub        func(storageType string, location string, size int, iops int) (*datatypes.Container_Product_Order_Receipt, error)
	orderBlockVolumeMutex       sync.RWMutex
	orderBlockVolumeArgsForCall []struct {
		storageType string
		location    string
		size        int
		iops        int
	}
	orderBlockVolumeReturns struct {
		result1 *datatypes.Container_Product_Order_Receipt
		result2 error
	}
	orderBlockVolumeReturnsOnCall map[int]struct {
		result1 *datatypes.Container_Product_Order_Receipt
		result2 error
	}
	CancelBlockVolumeStub        func(volumeId int, reason string, immediate bool) (bool, error)
	cancelBlockVolumeMutex       sync.RWMutex
	cancelBlockVolumeArgsForCall []struct {
		volumeId  int
		reason    string
		immediate bool
	}
	cancelBlockVolumeReturns struct {
		result1 bool
		result2 error
	}
	cancelBlockVolumeReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	GetBlockVolumeDetailsStub        func(volumeId int, mask string) (*datatypes.Network_Storage, bool, error)
	getBlockVolumeDetailsMutex       sync.RWMutex
	getBlockVolumeDetailsArgsForCall []struct {
		volumeId int
		mask     string
	}
	getBlockVolumeDetailsReturns struct {
		result1 *datatypes.Network_Storage
		result2 bool
		result3 error
	}
	getBlockVolumeDetailsReturnsOnCall map[int]struct {
		result1 *datatypes.Network_Storage
		result2 bool
		result3 error
	}
	GetBlockVolumeDetails2Stub        func(volumeId int, mask string) (datatypes.Network_Storage, bool, error)
	getBlockVolumeDetails2Mutex       sync.RWMutex
	getBlockVolumeDetails2ArgsForCall []struct {
		volumeId int
		mask     string
	}
	getBlockVolumeDetails2Returns struct {
		result1 datatypes.Network_Storage
		result2 bool
		result3 error
	}
	getBlockVolumeDetails2ReturnsOnCall map[int]struct {
		result1 datatypes.Network_Storage
		result2 bool
		result3 error
	}
	GetNetworkStorageTargetStub        func(volumeId int, mask string) (string, bool, error)
	getNetworkStorageTargetMutex       sync.RWMutex
	getNetworkStorageTargetArgsForCall []struct {
		volumeId int
		mask     string
	}
	getNetworkStorageTargetReturns struct {
		result1 string
		result2 bool
		result3 error
	}
	getNetworkStorageTargetReturnsOnCall map[int]struct {
		result1 string
		result2 bool
		result3 error
	}
	GetImageStub        func(imageId int, mask string) (*datatypes.Virtual_Guest_Block_Device_Template_Group, bool, error)
	getImageMutex       sync.RWMutex
	getImageArgsForCall []struct {
		imageId int
		mask    string
	}
	getImageReturns struct {
		result1 *datatypes.Virtual_Guest_Block_Device_Template_Group
		result2 bool
		result3 error
	}
	getImageReturnsOnCall map[int]struct {
		result1 *datatypes.Virtual_Guest_Block_Device_Template_Group
		result2 bool
		result3 error
	}
	GetVlanStub        func(id int, mask string) (*datatypes.Network_Vlan, bool, error)
	getVlanMutex       sync.RWMutex
	getVlanArgsForCall []struct {
		id   int
		mask string
	}
	getVlanReturns struct {
		result1 *datatypes.Network_Vlan
		result2 bool
		result3 error
	}
	getVlanReturnsOnCall map[int]struct {
		result1 *datatypes.Network_Vlan
		result2 bool
		result3 error
	}
	GetAllowedHostCredentialStub        func(id int) (*datatypes.Network_Storage_Allowed_Host, bool, error)
	getAllowedHostCredentialMutex       sync.RWMutex
	getAllowedHostCredentialArgsForCall []struct {
		id int
	}
	getAllowedHostCredentialReturns struct {
		result1 *datatypes.Network_Storage_Allowed_Host
		result2 bool
		result3 error
	}
	getAllowedHostCredentialReturnsOnCall map[int]struct {
		result1 *datatypes.Network_Storage_Allowed_Host
		result2 bool
		result3 error
	}
	GetAllowedNetworkStorageStub        func(id int) ([]string, bool, error)
	getAllowedNetworkStorageMutex       sync.RWMutex
	getAllowedNetworkStorageArgsForCall []struct {
		id int
	}
	getAllowedNetworkStorageReturns struct {
		result1 []string
		result2 bool
		result3 error
	}
	getAllowedNetworkStorageReturnsOnCall map[int]struct {
		result1 []string
		result2 bool
		result3 error
	}
	CreateSshKeyStub        func(label *string, key *string, fingerPrint *string) (*datatypes.Security_Ssh_Key, error)
	createSshKeyMutex       sync.RWMutex
	createSshKeyArgsForCall []struct {
		label       *string
		key         *string
		fingerPrint *string
	}
	createSshKeyReturns struct {
		result1 *datatypes.Security_Ssh_Key
		result2 error
	}
	createSshKeyReturnsOnCall map[int]struct {
		result1 *datatypes.Security_Ssh_Key
		result2 error
	}
	DeleteSshKeyStub        func(id int) (bool, error)
	deleteSshKeyMutex       sync.RWMutex
	deleteSshKeyArgsForCall []struct {
		id int
	}
	deleteSshKeyReturns struct {
		result1 bool
		result2 error
	}
	deleteSshKeyReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	CreateInstanceFromVPSStub        func(template *datatypes.Virtual_Guest, stemcellID int, sshKeys []int) (*datatypes.Virtual_Guest, error)
	createInstanceFromVPSMutex       sync.RWMutex
	createInstanceFromVPSArgsForCall []struct {
		template   *datatypes.Virtual_Guest
		stemcellID int
		sshKeys    []int
	}
	createInstanceFromVPSReturns struct {
		result1 *datatypes.Virtual_Guest
		result2 error
	}
	createInstanceFromVPSReturnsOnCall map[int]struct {
		result1 *datatypes.Virtual_Guest
		result2 error
	}
	DeleteInstanceFromVPSStub        func(id int) error
	deleteInstanceFromVPSMutex       sync.RWMutex
	deleteInstanceFromVPSArgsForCall []struct {
		id int
	}
	deleteInstanceFromVPSReturns struct {
		result1 error
	}
	deleteInstanceFromVPSReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) CancelInstance(id int) error {
	fake.cancelInstanceMutex.Lock()
	ret, specificReturn := fake.cancelInstanceReturnsOnCall[len(fake.cancelInstanceArgsForCall)]
	fake.cancelInstanceArgsForCall = append(fake.cancelInstanceArgsForCall, struct {
		id int
	}{id})
	fake.recordInvocation("CancelInstance", []interface{}{id})
	fake.cancelInstanceMutex.Unlock()
	if fake.CancelInstanceStub != nil {
		return fake.CancelInstanceStub(id)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.cancelInstanceReturns.result1
}

func (fake *FakeClient) CancelInstanceCallCount() int {
	fake.cancelInstanceMutex.RLock()
	defer fake.cancelInstanceMutex.RUnlock()
	return len(fake.cancelInstanceArgsForCall)
}

func (fake *FakeClient) CancelInstanceArgsForCall(i int) int {
	fake.cancelInstanceMutex.RLock()
	defer fake.cancelInstanceMutex.RUnlock()
	return fake.cancelInstanceArgsForCall[i].id
}

func (fake *FakeClient) CancelInstanceReturns(result1 error) {
	fake.CancelInstanceStub = nil
	fake.cancelInstanceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) CancelInstanceReturnsOnCall(i int, result1 error) {
	fake.CancelInstanceStub = nil
	if fake.cancelInstanceReturnsOnCall == nil {
		fake.cancelInstanceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cancelInstanceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) CreateInstance(template *datatypes.Virtual_Guest) (*datatypes.Virtual_Guest, error) {
	fake.createInstanceMutex.Lock()
	ret, specificReturn := fake.createInstanceReturnsOnCall[len(fake.createInstanceArgsForCall)]
	fake.createInstanceArgsForCall = append(fake.createInstanceArgsForCall, struct {
		template *datatypes.Virtual_Guest
	}{template})
	fake.recordInvocation("CreateInstance", []interface{}{template})
	fake.createInstanceMutex.Unlock()
	if fake.CreateInstanceStub != nil {
		return fake.CreateInstanceStub(template)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createInstanceReturns.result1, fake.createInstanceReturns.result2
}

func (fake *FakeClient) CreateInstanceCallCount() int {
	fake.createInstanceMutex.RLock()
	defer fake.createInstanceMutex.RUnlock()
	return len(fake.createInstanceArgsForCall)
}

func (fake *FakeClient) CreateInstanceArgsForCall(i int) *datatypes.Virtual_Guest {
	fake.createInstanceMutex.RLock()
	defer fake.createInstanceMutex.RUnlock()
	return fake.createInstanceArgsForCall[i].template
}

func (fake *FakeClient) CreateInstanceReturns(result1 *datatypes.Virtual_Guest, result2 error) {
	fake.CreateInstanceStub = nil
	fake.createInstanceReturns = struct {
		result1 *datatypes.Virtual_Guest
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateInstanceReturnsOnCall(i int, result1 *datatypes.Virtual_Guest, result2 error) {
	fake.CreateInstanceStub = nil
	if fake.createInstanceReturnsOnCall == nil {
		fake.createInstanceReturnsOnCall = make(map[int]struct {
			result1 *datatypes.Virtual_Guest
			result2 error
		})
	}
	fake.createInstanceReturnsOnCall[i] = struct {
		result1 *datatypes.Virtual_Guest
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) EditInstance(id int, template *datatypes.Virtual_Guest) (bool, error) {
	fake.editInstanceMutex.Lock()
	ret, specificReturn := fake.editInstanceReturnsOnCall[len(fake.editInstanceArgsForCall)]
	fake.editInstanceArgsForCall = append(fake.editInstanceArgsForCall, struct {
		id       int
		template *datatypes.Virtual_Guest
	}{id, template})
	fake.recordInvocation("EditInstance", []interface{}{id, template})
	fake.editInstanceMutex.Unlock()
	if fake.EditInstanceStub != nil {
		return fake.EditInstanceStub(id, template)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.editInstanceReturns.result1, fake.editInstanceReturns.result2
}

func (fake *FakeClient) EditInstanceCallCount() int {
	fake.editInstanceMutex.RLock()
	defer fake.editInstanceMutex.RUnlock()
	return len(fake.editInstanceArgsForCall)
}

func (fake *FakeClient) EditInstanceArgsForCall(i int) (int, *datatypes.Virtual_Guest) {
	fake.editInstanceMutex.RLock()
	defer fake.editInstanceMutex.RUnlock()
	return fake.editInstanceArgsForCall[i].id, fake.editInstanceArgsForCall[i].template
}

func (fake *FakeClient) EditInstanceReturns(result1 bool, result2 error) {
	fake.EditInstanceStub = nil
	fake.editInstanceReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) EditInstanceReturnsOnCall(i int, result1 bool, result2 error) {
	fake.EditInstanceStub = nil
	if fake.editInstanceReturnsOnCall == nil {
		fake.editInstanceReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.editInstanceReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetInstance(id int, mask string) (*datatypes.Virtual_Guest, bool, error) {
	fake.getInstanceMutex.Lock()
	ret, specificReturn := fake.getInstanceReturnsOnCall[len(fake.getInstanceArgsForCall)]
	fake.getInstanceArgsForCall = append(fake.getInstanceArgsForCall, struct {
		id   int
		mask string
	}{id, mask})
	fake.recordInvocation("GetInstance", []interface{}{id, mask})
	fake.getInstanceMutex.Unlock()
	if fake.GetInstanceStub != nil {
		return fake.GetInstanceStub(id, mask)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.getInstanceReturns.result1, fake.getInstanceReturns.result2, fake.getInstanceReturns.result3
}

func (fake *FakeClient) GetInstanceCallCount() int {
	fake.getInstanceMutex.RLock()
	defer fake.getInstanceMutex.RUnlock()
	return len(fake.getInstanceArgsForCall)
}

func (fake *FakeClient) GetInstanceArgsForCall(i int) (int, string) {
	fake.getInstanceMutex.RLock()
	defer fake.getInstanceMutex.RUnlock()
	return fake.getInstanceArgsForCall[i].id, fake.getInstanceArgsForCall[i].mask
}

func (fake *FakeClient) GetInstanceReturns(result1 *datatypes.Virtual_Guest, result2 bool, result3 error) {
	fake.GetInstanceStub = nil
	fake.getInstanceReturns = struct {
		result1 *datatypes.Virtual_Guest
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetInstanceReturnsOnCall(i int, result1 *datatypes.Virtual_Guest, result2 bool, result3 error) {
	fake.GetInstanceStub = nil
	if fake.getInstanceReturnsOnCall == nil {
		fake.getInstanceReturnsOnCall = make(map[int]struct {
			result1 *datatypes.Virtual_Guest
			result2 bool
			result3 error
		})
	}
	fake.getInstanceReturnsOnCall[i] = struct {
		result1 *datatypes.Virtual_Guest
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetInstanceByPrimaryBackendIpAddress(ip string) (*datatypes.Virtual_Guest, bool, error) {
	fake.getInstanceByPrimaryBackendIpAddressMutex.Lock()
	ret, specificReturn := fake.getInstanceByPrimaryBackendIpAddressReturnsOnCall[len(fake.getInstanceByPrimaryBackendIpAddressArgsForCall)]
	fake.getInstanceByPrimaryBackendIpAddressArgsForCall = append(fake.getInstanceByPrimaryBackendIpAddressArgsForCall, struct {
		ip string
	}{ip})
	fake.recordInvocation("GetInstanceByPrimaryBackendIpAddress", []interface{}{ip})
	fake.getInstanceByPrimaryBackendIpAddressMutex.Unlock()
	if fake.GetInstanceByPrimaryBackendIpAddressStub != nil {
		return fake.GetInstanceByPrimaryBackendIpAddressStub(ip)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.getInstanceByPrimaryBackendIpAddressReturns.result1, fake.getInstanceByPrimaryBackendIpAddressReturns.result2, fake.getInstanceByPrimaryBackendIpAddressReturns.result3
}

func (fake *FakeClient) GetInstanceByPrimaryBackendIpAddressCallCount() int {
	fake.getInstanceByPrimaryBackendIpAddressMutex.RLock()
	defer fake.getInstanceByPrimaryBackendIpAddressMutex.RUnlock()
	return len(fake.getInstanceByPrimaryBackendIpAddressArgsForCall)
}

func (fake *FakeClient) GetInstanceByPrimaryBackendIpAddressArgsForCall(i int) string {
	fake.getInstanceByPrimaryBackendIpAddressMutex.RLock()
	defer fake.getInstanceByPrimaryBackendIpAddressMutex.RUnlock()
	return fake.getInstanceByPrimaryBackendIpAddressArgsForCall[i].ip
}

func (fake *FakeClient) GetInstanceByPrimaryBackendIpAddressReturns(result1 *datatypes.Virtual_Guest, result2 bool, result3 error) {
	fake.GetInstanceByPrimaryBackendIpAddressStub = nil
	fake.getInstanceByPrimaryBackendIpAddressReturns = struct {
		result1 *datatypes.Virtual_Guest
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetInstanceByPrimaryBackendIpAddressReturnsOnCall(i int, result1 *datatypes.Virtual_Guest, result2 bool, result3 error) {
	fake.GetInstanceByPrimaryBackendIpAddressStub = nil
	if fake.getInstanceByPrimaryBackendIpAddressReturnsOnCall == nil {
		fake.getInstanceByPrimaryBackendIpAddressReturnsOnCall = make(map[int]struct {
			result1 *datatypes.Virtual_Guest
			result2 bool
			result3 error
		})
	}
	fake.getInstanceByPrimaryBackendIpAddressReturnsOnCall[i] = struct {
		result1 *datatypes.Virtual_Guest
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetInstanceByPrimaryIpAddress(ip string) (*datatypes.Virtual_Guest, bool, error) {
	fake.getInstanceByPrimaryIpAddressMutex.Lock()
	ret, specificReturn := fake.getInstanceByPrimaryIpAddressReturnsOnCall[len(fake.getInstanceByPrimaryIpAddressArgsForCall)]
	fake.getInstanceByPrimaryIpAddressArgsForCall = append(fake.getInstanceByPrimaryIpAddressArgsForCall, struct {
		ip string
	}{ip})
	fake.recordInvocation("GetInstanceByPrimaryIpAddress", []interface{}{ip})
	fake.getInstanceByPrimaryIpAddressMutex.Unlock()
	if fake.GetInstanceByPrimaryIpAddressStub != nil {
		return fake.GetInstanceByPrimaryIpAddressStub(ip)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.getInstanceByPrimaryIpAddressReturns.result1, fake.getInstanceByPrimaryIpAddressReturns.result2, fake.getInstanceByPrimaryIpAddressReturns.result3
}

func (fake *FakeClient) GetInstanceByPrimaryIpAddressCallCount() int {
	fake.getInstanceByPrimaryIpAddressMutex.RLock()
	defer fake.getInstanceByPrimaryIpAddressMutex.RUnlock()
	return len(fake.getInstanceByPrimaryIpAddressArgsForCall)
}

func (fake *FakeClient) GetInstanceByPrimaryIpAddressArgsForCall(i int) string {
	fake.getInstanceByPrimaryIpAddressMutex.RLock()
	defer fake.getInstanceByPrimaryIpAddressMutex.RUnlock()
	return fake.getInstanceByPrimaryIpAddressArgsForCall[i].ip
}

func (fake *FakeClient) GetInstanceByPrimaryIpAddressReturns(result1 *datatypes.Virtual_Guest, result2 bool, result3 error) {
	fake.GetInstanceByPrimaryIpAddressStub = nil
	fake.getInstanceByPrimaryIpAddressReturns = struct {
		result1 *datatypes.Virtual_Guest
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetInstanceByPrimaryIpAddressReturnsOnCall(i int, result1 *datatypes.Virtual_Guest, result2 bool, result3 error) {
	fake.GetInstanceByPrimaryIpAddressStub = nil
	if fake.getInstanceByPrimaryIpAddressReturnsOnCall == nil {
		fake.getInstanceByPrimaryIpAddressReturnsOnCall = make(map[int]struct {
			result1 *datatypes.Virtual_Guest
			result2 bool
			result3 error
		})
	}
	fake.getInstanceByPrimaryIpAddressReturnsOnCall[i] = struct {
		result1 *datatypes.Virtual_Guest
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) RebootInstance(id int, soft bool, hard bool) error {
	fake.rebootInstanceMutex.Lock()
	ret, specificReturn := fake.rebootInstanceReturnsOnCall[len(fake.rebootInstanceArgsForCall)]
	fake.rebootInstanceArgsForCall = append(fake.rebootInstanceArgsForCall, struct {
		id   int
		soft bool
		hard bool
	}{id, soft, hard})
	fake.recordInvocation("RebootInstance", []interface{}{id, soft, hard})
	fake.rebootInstanceMutex.Unlock()
	if fake.RebootInstanceStub != nil {
		return fake.RebootInstanceStub(id, soft, hard)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.rebootInstanceReturns.result1
}

func (fake *FakeClient) RebootInstanceCallCount() int {
	fake.rebootInstanceMutex.RLock()
	defer fake.rebootInstanceMutex.RUnlock()
	return len(fake.rebootInstanceArgsForCall)
}

func (fake *FakeClient) RebootInstanceArgsForCall(i int) (int, bool, bool) {
	fake.rebootInstanceMutex.RLock()
	defer fake.rebootInstanceMutex.RUnlock()
	return fake.rebootInstanceArgsForCall[i].id, fake.rebootInstanceArgsForCall[i].soft, fake.rebootInstanceArgsForCall[i].hard
}

func (fake *FakeClient) RebootInstanceReturns(result1 error) {
	fake.RebootInstanceStub = nil
	fake.rebootInstanceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) RebootInstanceReturnsOnCall(i int, result1 error) {
	fake.RebootInstanceStub = nil
	if fake.rebootInstanceReturnsOnCall == nil {
		fake.rebootInstanceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.rebootInstanceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) ReloadInstance(id int, stemcellId int, sshKeyIds []int, hostname string, domain string) error {
	var sshKeyIdsCopy []int
	if sshKeyIds != nil {
		sshKeyIdsCopy = make([]int, len(sshKeyIds))
		copy(sshKeyIdsCopy, sshKeyIds)
	}
	fake.reloadInstanceMutex.Lock()
	ret, specificReturn := fake.reloadInstanceReturnsOnCall[len(fake.reloadInstanceArgsForCall)]
	fake.reloadInstanceArgsForCall = append(fake.reloadInstanceArgsForCall, struct {
		id         int
		stemcellId int
		sshKeyIds  []int
		hostname   string
		domain     string
	}{id, stemcellId, sshKeyIdsCopy, hostname, domain})
	fake.recordInvocation("ReloadInstance", []interface{}{id, stemcellId, sshKeyIdsCopy, hostname, domain})
	fake.reloadInstanceMutex.Unlock()
	if fake.ReloadInstanceStub != nil {
		return fake.ReloadInstanceStub(id, stemcellId, sshKeyIds, hostname, domain)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.reloadInstanceReturns.result1
}

func (fake *FakeClient) ReloadInstanceCallCount() int {
	fake.reloadInstanceMutex.RLock()
	defer fake.reloadInstanceMutex.RUnlock()
	return len(fake.reloadInstanceArgsForCall)
}

func (fake *FakeClient) ReloadInstanceArgsForCall(i int) (int, int, []int, string, string) {
	fake.reloadInstanceMutex.RLock()
	defer fake.reloadInstanceMutex.RUnlock()
	return fake.reloadInstanceArgsForCall[i].id, fake.reloadInstanceArgsForCall[i].stemcellId, fake.reloadInstanceArgsForCall[i].sshKeyIds, fake.reloadInstanceArgsForCall[i].hostname, fake.reloadInstanceArgsForCall[i].domain
}

func (fake *FakeClient) ReloadInstanceReturns(result1 error) {
	fake.ReloadInstanceStub = nil
	fake.reloadInstanceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) ReloadInstanceReturnsOnCall(i int, result1 error) {
	fake.ReloadInstanceStub = nil
	if fake.reloadInstanceReturnsOnCall == nil {
		fake.reloadInstanceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.reloadInstanceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) UpgradeInstanceConfig(id int, cpu int, memory int, network int, privateCPU bool) error {
	fake.upgradeInstanceConfigMutex.Lock()
	ret, specificReturn := fake.upgradeInstanceConfigReturnsOnCall[len(fake.upgradeInstanceConfigArgsForCall)]
	fake.upgradeInstanceConfigArgsForCall = append(fake.upgradeInstanceConfigArgsForCall, struct {
		id         int
		cpu        int
		memory     int
		network    int
		privateCPU bool
	}{id, cpu, memory, network, privateCPU})
	fake.recordInvocation("UpgradeInstanceConfig", []interface{}{id, cpu, memory, network, privateCPU})
	fake.upgradeInstanceConfigMutex.Unlock()
	if fake.UpgradeInstanceConfigStub != nil {
		return fake.UpgradeInstanceConfigStub(id, cpu, memory, network, privateCPU)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.upgradeInstanceConfigReturns.result1
}

func (fake *FakeClient) UpgradeInstanceConfigCallCount() int {
	fake.upgradeInstanceConfigMutex.RLock()
	defer fake.upgradeInstanceConfigMutex.RUnlock()
	return len(fake.upgradeInstanceConfigArgsForCall)
}

func (fake *FakeClient) UpgradeInstanceConfigArgsForCall(i int) (int, int, int, int, bool) {
	fake.upgradeInstanceConfigMutex.RLock()
	defer fake.upgradeInstanceConfigMutex.RUnlock()
	return fake.upgradeInstanceConfigArgsForCall[i].id, fake.upgradeInstanceConfigArgsForCall[i].cpu, fake.upgradeInstanceConfigArgsForCall[i].memory, fake.upgradeInstanceConfigArgsForCall[i].network, fake.upgradeInstanceConfigArgsForCall[i].privateCPU
}

func (fake *FakeClient) UpgradeInstanceConfigReturns(result1 error) {
	fake.UpgradeInstanceConfigStub = nil
	fake.upgradeInstanceConfigReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) UpgradeInstanceConfigReturnsOnCall(i int, result1 error) {
	fake.UpgradeInstanceConfigStub = nil
	if fake.upgradeInstanceConfigReturnsOnCall == nil {
		fake.upgradeInstanceConfigReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.upgradeInstanceConfigReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) UpgradeInstance(id int, cpu int, memory int, network int, privateCPU bool, additional_diskSize int) (*datatypes.Container_Product_Order_Receipt, error) {
	fake.upgradeInstanceMutex.Lock()
	ret, specificReturn := fake.upgradeInstanceReturnsOnCall[len(fake.upgradeInstanceArgsForCall)]
	fake.upgradeInstanceArgsForCall = append(fake.upgradeInstanceArgsForCall, struct {
		id                  int
		cpu                 int
		memory              int
		network             int
		privateCPU          bool
		additional_diskSize int
	}{id, cpu, memory, network, privateCPU, additional_diskSize})
	fake.recordInvocation("UpgradeInstance", []interface{}{id, cpu, memory, network, privateCPU, additional_diskSize})
	fake.upgradeInstanceMutex.Unlock()
	if fake.UpgradeInstanceStub != nil {
		return fake.UpgradeInstanceStub(id, cpu, memory, network, privateCPU, additional_diskSize)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.upgradeInstanceReturns.result1, fake.upgradeInstanceReturns.result2
}

func (fake *FakeClient) UpgradeInstanceCallCount() int {
	fake.upgradeInstanceMutex.RLock()
	defer fake.upgradeInstanceMutex.RUnlock()
	return len(fake.upgradeInstanceArgsForCall)
}

func (fake *FakeClient) UpgradeInstanceArgsForCall(i int) (int, int, int, int, bool, int) {
	fake.upgradeInstanceMutex.RLock()
	defer fake.upgradeInstanceMutex.RUnlock()
	return fake.upgradeInstanceArgsForCall[i].id, fake.upgradeInstanceArgsForCall[i].cpu, fake.upgradeInstanceArgsForCall[i].memory, fake.upgradeInstanceArgsForCall[i].network, fake.upgradeInstanceArgsForCall[i].privateCPU, fake.upgradeInstanceArgsForCall[i].additional_diskSize
}

func (fake *FakeClient) UpgradeInstanceReturns(result1 *datatypes.Container_Product_Order_Receipt, result2 error) {
	fake.UpgradeInstanceStub = nil
	fake.upgradeInstanceReturns = struct {
		result1 *datatypes.Container_Product_Order_Receipt
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpgradeInstanceReturnsOnCall(i int, result1 *datatypes.Container_Product_Order_Receipt, result2 error) {
	fake.UpgradeInstanceStub = nil
	if fake.upgradeInstanceReturnsOnCall == nil {
		fake.upgradeInstanceReturnsOnCall = make(map[int]struct {
			result1 *datatypes.Container_Product_Order_Receipt
			result2 error
		})
	}
	fake.upgradeInstanceReturnsOnCall[i] = struct {
		result1 *datatypes.Container_Product_Order_Receipt
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) WaitInstanceUntilReady(id int, until time.Time) error {
	fake.waitInstanceUntilReadyMutex.Lock()
	ret, specificReturn := fake.waitInstanceUntilReadyReturnsOnCall[len(fake.waitInstanceUntilReadyArgsForCall)]
	fake.waitInstanceUntilReadyArgsForCall = append(fake.waitInstanceUntilReadyArgsForCall, struct {
		id    int
		until time.Time
	}{id, until})
	fake.recordInvocation("WaitInstanceUntilReady", []interface{}{id, until})
	fake.waitInstanceUntilReadyMutex.Unlock()
	if fake.WaitInstanceUntilReadyStub != nil {
		return fake.WaitInstanceUntilReadyStub(id, until)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.waitInstanceUntilReadyReturns.result1
}

func (fake *FakeClient) WaitInstanceUntilReadyCallCount() int {
	fake.waitInstanceUntilReadyMutex.RLock()
	defer fake.waitInstanceUntilReadyMutex.RUnlock()
	return len(fake.waitInstanceUntilReadyArgsForCall)
}

func (fake *FakeClient) WaitInstanceUntilReadyArgsForCall(i int) (int, time.Time) {
	fake.waitInstanceUntilReadyMutex.RLock()
	defer fake.waitInstanceUntilReadyMutex.RUnlock()
	return fake.waitInstanceUntilReadyArgsForCall[i].id, fake.waitInstanceUntilReadyArgsForCall[i].until
}

func (fake *FakeClient) WaitInstanceUntilReadyReturns(result1 error) {
	fake.WaitInstanceUntilReadyStub = nil
	fake.waitInstanceUntilReadyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WaitInstanceUntilReadyReturnsOnCall(i int, result1 error) {
	fake.WaitInstanceUntilReadyStub = nil
	if fake.waitInstanceUntilReadyReturnsOnCall == nil {
		fake.waitInstanceUntilReadyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.waitInstanceUntilReadyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WaitInstanceHasActiveTransaction(id int, until time.Time) error {
	fake.waitInstanceHasActiveTransactionMutex.Lock()
	ret, specificReturn := fake.waitInstanceHasActiveTransactionReturnsOnCall[len(fake.waitInstanceHasActiveTransactionArgsForCall)]
	fake.waitInstanceHasActiveTransactionArgsForCall = append(fake.waitInstanceHasActiveTransactionArgsForCall, struct {
		id    int
		until time.Time
	}{id, until})
	fake.recordInvocation("WaitInstanceHasActiveTransaction", []interface{}{id, until})
	fake.waitInstanceHasActiveTransactionMutex.Unlock()
	if fake.WaitInstanceHasActiveTransactionStub != nil {
		return fake.WaitInstanceHasActiveTransactionStub(id, until)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.waitInstanceHasActiveTransactionReturns.result1
}

func (fake *FakeClient) WaitInstanceHasActiveTransactionCallCount() int {
	fake.waitInstanceHasActiveTransactionMutex.RLock()
	defer fake.waitInstanceHasActiveTransactionMutex.RUnlock()
	return len(fake.waitInstanceHasActiveTransactionArgsForCall)
}

func (fake *FakeClient) WaitInstanceHasActiveTransactionArgsForCall(i int) (int, time.Time) {
	fake.waitInstanceHasActiveTransactionMutex.RLock()
	defer fake.waitInstanceHasActiveTransactionMutex.RUnlock()
	return fake.waitInstanceHasActiveTransactionArgsForCall[i].id, fake.waitInstanceHasActiveTransactionArgsForCall[i].until
}

func (fake *FakeClient) WaitInstanceHasActiveTransactionReturns(result1 error) {
	fake.WaitInstanceHasActiveTransactionStub = nil
	fake.waitInstanceHasActiveTransactionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WaitInstanceHasActiveTransactionReturnsOnCall(i int, result1 error) {
	fake.WaitInstanceHasActiveTransactionStub = nil
	if fake.waitInstanceHasActiveTransactionReturnsOnCall == nil {
		fake.waitInstanceHasActiveTransactionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.waitInstanceHasActiveTransactionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WaitInstanceHasNoneActiveTransaction(id int, until time.Time) error {
	fake.waitInstanceHasNoneActiveTransactionMutex.Lock()
	ret, specificReturn := fake.waitInstanceHasNoneActiveTransactionReturnsOnCall[len(fake.waitInstanceHasNoneActiveTransactionArgsForCall)]
	fake.waitInstanceHasNoneActiveTransactionArgsForCall = append(fake.waitInstanceHasNoneActiveTransactionArgsForCall, struct {
		id    int
		until time.Time
	}{id, until})
	fake.recordInvocation("WaitInstanceHasNoneActiveTransaction", []interface{}{id, until})
	fake.waitInstanceHasNoneActiveTransactionMutex.Unlock()
	if fake.WaitInstanceHasNoneActiveTransactionStub != nil {
		return fake.WaitInstanceHasNoneActiveTransactionStub(id, until)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.waitInstanceHasNoneActiveTransactionReturns.result1
}

func (fake *FakeClient) WaitInstanceHasNoneActiveTransactionCallCount() int {
	fake.waitInstanceHasNoneActiveTransactionMutex.RLock()
	defer fake.waitInstanceHasNoneActiveTransactionMutex.RUnlock()
	return len(fake.waitInstanceHasNoneActiveTransactionArgsForCall)
}

func (fake *FakeClient) WaitInstanceHasNoneActiveTransactionArgsForCall(i int) (int, time.Time) {
	fake.waitInstanceHasNoneActiveTransactionMutex.RLock()
	defer fake.waitInstanceHasNoneActiveTransactionMutex.RUnlock()
	return fake.waitInstanceHasNoneActiveTransactionArgsForCall[i].id, fake.waitInstanceHasNoneActiveTransactionArgsForCall[i].until
}

func (fake *FakeClient) WaitInstanceHasNoneActiveTransactionReturns(result1 error) {
	fake.WaitInstanceHasNoneActiveTransactionStub = nil
	fake.waitInstanceHasNoneActiveTransactionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WaitInstanceHasNoneActiveTransactionReturnsOnCall(i int, result1 error) {
	fake.WaitInstanceHasNoneActiveTransactionStub = nil
	if fake.waitInstanceHasNoneActiveTransactionReturnsOnCall == nil {
		fake.waitInstanceHasNoneActiveTransactionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.waitInstanceHasNoneActiveTransactionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WaitVolumeProvisioningWithOrderId(orderId int, until time.Time) (*datatypes.Network_Storage, error) {
	fake.waitVolumeProvisioningWithOrderIdMutex.Lock()
	ret, specificReturn := fake.waitVolumeProvisioningWithOrderIdReturnsOnCall[len(fake.waitVolumeProvisioningWithOrderIdArgsForCall)]
	fake.waitVolumeProvisioningWithOrderIdArgsForCall = append(fake.waitVolumeProvisioningWithOrderIdArgsForCall, struct {
		orderId int
		until   time.Time
	}{orderId, until})
	fake.recordInvocation("WaitVolumeProvisioningWithOrderId", []interface{}{orderId, until})
	fake.waitVolumeProvisioningWithOrderIdMutex.Unlock()
	if fake.WaitVolumeProvisioningWithOrderIdStub != nil {
		return fake.WaitVolumeProvisioningWithOrderIdStub(orderId, until)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.waitVolumeProvisioningWithOrderIdReturns.result1, fake.waitVolumeProvisioningWithOrderIdReturns.result2
}

func (fake *FakeClient) WaitVolumeProvisioningWithOrderIdCallCount() int {
	fake.waitVolumeProvisioningWithOrderIdMutex.RLock()
	defer fake.waitVolumeProvisioningWithOrderIdMutex.RUnlock()
	return len(fake.waitVolumeProvisioningWithOrderIdArgsForCall)
}

func (fake *FakeClient) WaitVolumeProvisioningWithOrderIdArgsForCall(i int) (int, time.Time) {
	fake.waitVolumeProvisioningWithOrderIdMutex.RLock()
	defer fake.waitVolumeProvisioningWithOrderIdMutex.RUnlock()
	return fake.waitVolumeProvisioningWithOrderIdArgsForCall[i].orderId, fake.waitVolumeProvisioningWithOrderIdArgsForCall[i].until
}

func (fake *FakeClient) WaitVolumeProvisioningWithOrderIdReturns(result1 *datatypes.Network_Storage, result2 error) {
	fake.WaitVolumeProvisioningWithOrderIdStub = nil
	fake.waitVolumeProvisioningWithOrderIdReturns = struct {
		result1 *datatypes.Network_Storage
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) WaitVolumeProvisioningWithOrderIdReturnsOnCall(i int, result1 *datatypes.Network_Storage, result2 error) {
	fake.WaitVolumeProvisioningWithOrderIdStub = nil
	if fake.waitVolumeProvisioningWithOrderIdReturnsOnCall == nil {
		fake.waitVolumeProvisioningWithOrderIdReturnsOnCall = make(map[int]struct {
			result1 *datatypes.Network_Storage
			result2 error
		})
	}
	fake.waitVolumeProvisioningWithOrderIdReturnsOnCall[i] = struct {
		result1 *datatypes.Network_Storage
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SetTags(id int, tags string) (bool, error) {
	fake.setTagsMutex.Lock()
	ret, specificReturn := fake.setTagsReturnsOnCall[len(fake.setTagsArgsForCall)]
	fake.setTagsArgsForCall = append(fake.setTagsArgsForCall, struct {
		id   int
		tags string
	}{id, tags})
	fake.recordInvocation("SetTags", []interface{}{id, tags})
	fake.setTagsMutex.Unlock()
	if fake.SetTagsStub != nil {
		return fake.SetTagsStub(id, tags)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.setTagsReturns.result1, fake.setTagsReturns.result2
}

func (fake *FakeClient) SetTagsCallCount() int {
	fake.setTagsMutex.RLock()
	defer fake.setTagsMutex.RUnlock()
	return len(fake.setTagsArgsForCall)
}

func (fake *FakeClient) SetTagsArgsForCall(i int) (int, string) {
	fake.setTagsMutex.RLock()
	defer fake.setTagsMutex.RUnlock()
	return fake.setTagsArgsForCall[i].id, fake.setTagsArgsForCall[i].tags
}

func (fake *FakeClient) SetTagsReturns(result1 bool, result2 error) {
	fake.SetTagsStub = nil
	fake.setTagsReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SetTagsReturnsOnCall(i int, result1 bool, result2 error) {
	fake.SetTagsStub = nil
	if fake.setTagsReturnsOnCall == nil {
		fake.setTagsReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.setTagsReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) AttachSecondDiskToInstance(id int, diskSize int) error {
	fake.attachSecondDiskToInstanceMutex.Lock()
	ret, specificReturn := fake.attachSecondDiskToInstanceReturnsOnCall[len(fake.attachSecondDiskToInstanceArgsForCall)]
	fake.attachSecondDiskToInstanceArgsForCall = append(fake.attachSecondDiskToInstanceArgsForCall, struct {
		id       int
		diskSize int
	}{id, diskSize})
	fake.recordInvocation("AttachSecondDiskToInstance", []interface{}{id, diskSize})
	fake.attachSecondDiskToInstanceMutex.Unlock()
	if fake.AttachSecondDiskToInstanceStub != nil {
		return fake.AttachSecondDiskToInstanceStub(id, diskSize)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.attachSecondDiskToInstanceReturns.result1
}

func (fake *FakeClient) AttachSecondDiskToInstanceCallCount() int {
	fake.attachSecondDiskToInstanceMutex.RLock()
	defer fake.attachSecondDiskToInstanceMutex.RUnlock()
	return len(fake.attachSecondDiskToInstanceArgsForCall)
}

func (fake *FakeClient) AttachSecondDiskToInstanceArgsForCall(i int) (int, int) {
	fake.attachSecondDiskToInstanceMutex.RLock()
	defer fake.attachSecondDiskToInstanceMutex.RUnlock()
	return fake.attachSecondDiskToInstanceArgsForCall[i].id, fake.attachSecondDiskToInstanceArgsForCall[i].diskSize
}

func (fake *FakeClient) AttachSecondDiskToInstanceReturns(result1 error) {
	fake.AttachSecondDiskToInstanceStub = nil
	fake.attachSecondDiskToInstanceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) AttachSecondDiskToInstanceReturnsOnCall(i int, result1 error) {
	fake.AttachSecondDiskToInstanceStub = nil
	if fake.attachSecondDiskToInstanceReturnsOnCall == nil {
		fake.attachSecondDiskToInstanceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.attachSecondDiskToInstanceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) GetInstanceAllowedHost(id int) (*datatypes.Network_Storage_Allowed_Host, bool, error) {
	fake.getInstanceAllowedHostMutex.Lock()
	ret, specificReturn := fake.getInstanceAllowedHostReturnsOnCall[len(fake.getInstanceAllowedHostArgsForCall)]
	fake.getInstanceAllowedHostArgsForCall = append(fake.getInstanceAllowedHostArgsForCall, struct {
		id int
	}{id})
	fake.recordInvocation("GetInstanceAllowedHost", []interface{}{id})
	fake.getInstanceAllowedHostMutex.Unlock()
	if fake.GetInstanceAllowedHostStub != nil {
		return fake.GetInstanceAllowedHostStub(id)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.getInstanceAllowedHostReturns.result1, fake.getInstanceAllowedHostReturns.result2, fake.getInstanceAllowedHostReturns.result3
}

func (fake *FakeClient) GetInstanceAllowedHostCallCount() int {
	fake.getInstanceAllowedHostMutex.RLock()
	defer fake.getInstanceAllowedHostMutex.RUnlock()
	return len(fake.getInstanceAllowedHostArgsForCall)
}

func (fake *FakeClient) GetInstanceAllowedHostArgsForCall(i int) int {
	fake.getInstanceAllowedHostMutex.RLock()
	defer fake.getInstanceAllowedHostMutex.RUnlock()
	return fake.getInstanceAllowedHostArgsForCall[i].id
}

func (fake *FakeClient) GetInstanceAllowedHostReturns(result1 *datatypes.Network_Storage_Allowed_Host, result2 bool, result3 error) {
	fake.GetInstanceAllowedHostStub = nil
	fake.getInstanceAllowedHostReturns = struct {
		result1 *datatypes.Network_Storage_Allowed_Host
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetInstanceAllowedHostReturnsOnCall(i int, result1 *datatypes.Network_Storage_Allowed_Host, result2 bool, result3 error) {
	fake.GetInstanceAllowedHostStub = nil
	if fake.getInstanceAllowedHostReturnsOnCall == nil {
		fake.getInstanceAllowedHostReturnsOnCall = make(map[int]struct {
			result1 *datatypes.Network_Storage_Allowed_Host
			result2 bool
			result3 error
		})
	}
	fake.getInstanceAllowedHostReturnsOnCall[i] = struct {
		result1 *datatypes.Network_Storage_Allowed_Host
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) AuthorizeHostToVolume(instance *datatypes.Virtual_Guest, volumeId int, until time.Time) (bool, error) {
	fake.authorizeHostToVolumeMutex.Lock()
	ret, specificReturn := fake.authorizeHostToVolumeReturnsOnCall[len(fake.authorizeHostToVolumeArgsForCall)]
	fake.authorizeHostToVolumeArgsForCall = append(fake.authorizeHostToVolumeArgsForCall, struct {
		instance *datatypes.Virtual_Guest
		volumeId int
		until    time.Time
	}{instance, volumeId, until})
	fake.recordInvocation("AuthorizeHostToVolume", []interface{}{instance, volumeId, until})
	fake.authorizeHostToVolumeMutex.Unlock()
	if fake.AuthorizeHostToVolumeStub != nil {
		return fake.AuthorizeHostToVolumeStub(instance, volumeId, until)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.authorizeHostToVolumeReturns.result1, fake.authorizeHostToVolumeReturns.result2
}

func (fake *FakeClient) AuthorizeHostToVolumeCallCount() int {
	fake.authorizeHostToVolumeMutex.RLock()
	defer fake.authorizeHostToVolumeMutex.RUnlock()
	return len(fake.authorizeHostToVolumeArgsForCall)
}

func (fake *FakeClient) AuthorizeHostToVolumeArgsForCall(i int) (*datatypes.Virtual_Guest, int, time.Time) {
	fake.authorizeHostToVolumeMutex.RLock()
	defer fake.authorizeHostToVolumeMutex.RUnlock()
	return fake.authorizeHostToVolumeArgsForCall[i].instance, fake.authorizeHostToVolumeArgsForCall[i].volumeId, fake.authorizeHostToVolumeArgsForCall[i].until
}

func (fake *FakeClient) AuthorizeHostToVolumeReturns(result1 bool, result2 error) {
	fake.AuthorizeHostToVolumeStub = nil
	fake.authorizeHostToVolumeReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) AuthorizeHostToVolumeReturnsOnCall(i int, result1 bool, result2 error) {
	fake.AuthorizeHostToVolumeStub = nil
	if fake.authorizeHostToVolumeReturnsOnCall == nil {
		fake.authorizeHostToVolumeReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.authorizeHostToVolumeReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DeauthorizeHostToVolume(instance *datatypes.Virtual_Guest, volumeId int, until time.Time) (bool, error) {
	fake.deauthorizeHostToVolumeMutex.Lock()
	ret, specificReturn := fake.deauthorizeHostToVolumeReturnsOnCall[len(fake.deauthorizeHostToVolumeArgsForCall)]
	fake.deauthorizeHostToVolumeArgsForCall = append(fake.deauthorizeHostToVolumeArgsForCall, struct {
		instance *datatypes.Virtual_Guest
		volumeId int
		until    time.Time
	}{instance, volumeId, until})
	fake.recordInvocation("DeauthorizeHostToVolume", []interface{}{instance, volumeId, until})
	fake.deauthorizeHostToVolumeMutex.Unlock()
	if fake.DeauthorizeHostToVolumeStub != nil {
		return fake.DeauthorizeHostToVolumeStub(instance, volumeId, until)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.deauthorizeHostToVolumeReturns.result1, fake.deauthorizeHostToVolumeReturns.result2
}

func (fake *FakeClient) DeauthorizeHostToVolumeCallCount() int {
	fake.deauthorizeHostToVolumeMutex.RLock()
	defer fake.deauthorizeHostToVolumeMutex.RUnlock()
	return len(fake.deauthorizeHostToVolumeArgsForCall)
}

func (fake *FakeClient) DeauthorizeHostToVolumeArgsForCall(i int) (*datatypes.Virtual_Guest, int, time.Time) {
	fake.deauthorizeHostToVolumeMutex.RLock()
	defer fake.deauthorizeHostToVolumeMutex.RUnlock()
	return fake.deauthorizeHostToVolumeArgsForCall[i].instance, fake.deauthorizeHostToVolumeArgsForCall[i].volumeId, fake.deauthorizeHostToVolumeArgsForCall[i].until
}

func (fake *FakeClient) DeauthorizeHostToVolumeReturns(result1 bool, result2 error) {
	fake.DeauthorizeHostToVolumeStub = nil
	fake.deauthorizeHostToVolumeReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DeauthorizeHostToVolumeReturnsOnCall(i int, result1 bool, result2 error) {
	fake.DeauthorizeHostToVolumeStub = nil
	if fake.deauthorizeHostToVolumeReturnsOnCall == nil {
		fake.deauthorizeHostToVolumeReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.deauthorizeHostToVolumeReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateVolume(location string, size int, iops int) (*datatypes.Network_Storage, error) {
	fake.createVolumeMutex.Lock()
	ret, specificReturn := fake.createVolumeReturnsOnCall[len(fake.createVolumeArgsForCall)]
	fake.createVolumeArgsForCall = append(fake.createVolumeArgsForCall, struct {
		location string
		size     int
		iops     int
	}{location, size, iops})
	fake.recordInvocation("CreateVolume", []interface{}{location, size, iops})
	fake.createVolumeMutex.Unlock()
	if fake.CreateVolumeStub != nil {
		return fake.CreateVolumeStub(location, size, iops)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createVolumeReturns.result1, fake.createVolumeReturns.result2
}

func (fake *FakeClient) CreateVolumeCallCount() int {
	fake.createVolumeMutex.RLock()
	defer fake.createVolumeMutex.RUnlock()
	return len(fake.createVolumeArgsForCall)
}

func (fake *FakeClient) CreateVolumeArgsForCall(i int) (string, int, int) {
	fake.createVolumeMutex.RLock()
	defer fake.createVolumeMutex.RUnlock()
	return fake.createVolumeArgsForCall[i].location, fake.createVolumeArgsForCall[i].size, fake.createVolumeArgsForCall[i].iops
}

func (fake *FakeClient) CreateVolumeReturns(result1 *datatypes.Network_Storage, result2 error) {
	fake.CreateVolumeStub = nil
	fake.createVolumeReturns = struct {
		result1 *datatypes.Network_Storage
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateVolumeReturnsOnCall(i int, result1 *datatypes.Network_Storage, result2 error) {
	fake.CreateVolumeStub = nil
	if fake.createVolumeReturnsOnCall == nil {
		fake.createVolumeReturnsOnCall = make(map[int]struct {
			result1 *datatypes.Network_Storage
			result2 error
		})
	}
	fake.createVolumeReturnsOnCall[i] = struct {
		result1 *datatypes.Network_Storage
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) OrderBlockVolume(storageType string, location string, size int, iops int) (*datatypes.Container_Product_Order_Receipt, error) {
	fake.orderBlockVolumeMutex.Lock()
	ret, specificReturn := fake.orderBlockVolumeReturnsOnCall[len(fake.orderBlockVolumeArgsForCall)]
	fake.orderBlockVolumeArgsForCall = append(fake.orderBlockVolumeArgsForCall, struct {
		storageType string
		location    string
		size        int
		iops        int
	}{storageType, location, size, iops})
	fake.recordInvocation("OrderBlockVolume", []interface{}{storageType, location, size, iops})
	fake.orderBlockVolumeMutex.Unlock()
	if fake.OrderBlockVolumeStub != nil {
		return fake.OrderBlockVolumeStub(storageType, location, size, iops)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.orderBlockVolumeReturns.result1, fake.orderBlockVolumeReturns.result2
}

func (fake *FakeClient) OrderBlockVolumeCallCount() int {
	fake.orderBlockVolumeMutex.RLock()
	defer fake.orderBlockVolumeMutex.RUnlock()
	return len(fake.orderBlockVolumeArgsForCall)
}

func (fake *FakeClient) OrderBlockVolumeArgsForCall(i int) (string, string, int, int) {
	fake.orderBlockVolumeMutex.RLock()
	defer fake.orderBlockVolumeMutex.RUnlock()
	return fake.orderBlockVolumeArgsForCall[i].storageType, fake.orderBlockVolumeArgsForCall[i].location, fake.orderBlockVolumeArgsForCall[i].size, fake.orderBlockVolumeArgsForCall[i].iops
}

func (fake *FakeClient) OrderBlockVolumeReturns(result1 *datatypes.Container_Product_Order_Receipt, result2 error) {
	fake.OrderBlockVolumeStub = nil
	fake.orderBlockVolumeReturns = struct {
		result1 *datatypes.Container_Product_Order_Receipt
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) OrderBlockVolumeReturnsOnCall(i int, result1 *datatypes.Container_Product_Order_Receipt, result2 error) {
	fake.OrderBlockVolumeStub = nil
	if fake.orderBlockVolumeReturnsOnCall == nil {
		fake.orderBlockVolumeReturnsOnCall = make(map[int]struct {
			result1 *datatypes.Container_Product_Order_Receipt
			result2 error
		})
	}
	fake.orderBlockVolumeReturnsOnCall[i] = struct {
		result1 *datatypes.Container_Product_Order_Receipt
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CancelBlockVolume(volumeId int, reason string, immediate bool) (bool, error) {
	fake.cancelBlockVolumeMutex.Lock()
	ret, specificReturn := fake.cancelBlockVolumeReturnsOnCall[len(fake.cancelBlockVolumeArgsForCall)]
	fake.cancelBlockVolumeArgsForCall = append(fake.cancelBlockVolumeArgsForCall, struct {
		volumeId  int
		reason    string
		immediate bool
	}{volumeId, reason, immediate})
	fake.recordInvocation("CancelBlockVolume", []interface{}{volumeId, reason, immediate})
	fake.cancelBlockVolumeMutex.Unlock()
	if fake.CancelBlockVolumeStub != nil {
		return fake.CancelBlockVolumeStub(volumeId, reason, immediate)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.cancelBlockVolumeReturns.result1, fake.cancelBlockVolumeReturns.result2
}

func (fake *FakeClient) CancelBlockVolumeCallCount() int {
	fake.cancelBlockVolumeMutex.RLock()
	defer fake.cancelBlockVolumeMutex.RUnlock()
	return len(fake.cancelBlockVolumeArgsForCall)
}

func (fake *FakeClient) CancelBlockVolumeArgsForCall(i int) (int, string, bool) {
	fake.cancelBlockVolumeMutex.RLock()
	defer fake.cancelBlockVolumeMutex.RUnlock()
	return fake.cancelBlockVolumeArgsForCall[i].volumeId, fake.cancelBlockVolumeArgsForCall[i].reason, fake.cancelBlockVolumeArgsForCall[i].immediate
}

func (fake *FakeClient) CancelBlockVolumeReturns(result1 bool, result2 error) {
	fake.CancelBlockVolumeStub = nil
	fake.cancelBlockVolumeReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CancelBlockVolumeReturnsOnCall(i int, result1 bool, result2 error) {
	fake.CancelBlockVolumeStub = nil
	if fake.cancelBlockVolumeReturnsOnCall == nil {
		fake.cancelBlockVolumeReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.cancelBlockVolumeReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetBlockVolumeDetails(volumeId int, mask string) (*datatypes.Network_Storage, bool, error) {
	fake.getBlockVolumeDetailsMutex.Lock()
	ret, specificReturn := fake.getBlockVolumeDetailsReturnsOnCall[len(fake.getBlockVolumeDetailsArgsForCall)]
	fake.getBlockVolumeDetailsArgsForCall = append(fake.getBlockVolumeDetailsArgsForCall, struct {
		volumeId int
		mask     string
	}{volumeId, mask})
	fake.recordInvocation("GetBlockVolumeDetails", []interface{}{volumeId, mask})
	fake.getBlockVolumeDetailsMutex.Unlock()
	if fake.GetBlockVolumeDetailsStub != nil {
		return fake.GetBlockVolumeDetailsStub(volumeId, mask)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.getBlockVolumeDetailsReturns.result1, fake.getBlockVolumeDetailsReturns.result2, fake.getBlockVolumeDetailsReturns.result3
}

func (fake *FakeClient) GetBlockVolumeDetailsCallCount() int {
	fake.getBlockVolumeDetailsMutex.RLock()
	defer fake.getBlockVolumeDetailsMutex.RUnlock()
	return len(fake.getBlockVolumeDetailsArgsForCall)
}

func (fake *FakeClient) GetBlockVolumeDetailsArgsForCall(i int) (int, string) {
	fake.getBlockVolumeDetailsMutex.RLock()
	defer fake.getBlockVolumeDetailsMutex.RUnlock()
	return fake.getBlockVolumeDetailsArgsForCall[i].volumeId, fake.getBlockVolumeDetailsArgsForCall[i].mask
}

func (fake *FakeClient) GetBlockVolumeDetailsReturns(result1 *datatypes.Network_Storage, result2 bool, result3 error) {
	fake.GetBlockVolumeDetailsStub = nil
	fake.getBlockVolumeDetailsReturns = struct {
		result1 *datatypes.Network_Storage
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetBlockVolumeDetailsReturnsOnCall(i int, result1 *datatypes.Network_Storage, result2 bool, result3 error) {
	fake.GetBlockVolumeDetailsStub = nil
	if fake.getBlockVolumeDetailsReturnsOnCall == nil {
		fake.getBlockVolumeDetailsReturnsOnCall = make(map[int]struct {
			result1 *datatypes.Network_Storage
			result2 bool
			result3 error
		})
	}
	fake.getBlockVolumeDetailsReturnsOnCall[i] = struct {
		result1 *datatypes.Network_Storage
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetBlockVolumeDetails2(volumeId int, mask string) (datatypes.Network_Storage, bool, error) {
	fake.getBlockVolumeDetails2Mutex.Lock()
	ret, specificReturn := fake.getBlockVolumeDetails2ReturnsOnCall[len(fake.getBlockVolumeDetails2ArgsForCall)]
	fake.getBlockVolumeDetails2ArgsForCall = append(fake.getBlockVolumeDetails2ArgsForCall, struct {
		volumeId int
		mask     string
	}{volumeId, mask})
	fake.recordInvocation("GetBlockVolumeDetails2", []interface{}{volumeId, mask})
	fake.getBlockVolumeDetails2Mutex.Unlock()
	if fake.GetBlockVolumeDetails2Stub != nil {
		return fake.GetBlockVolumeDetails2Stub(volumeId, mask)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.getBlockVolumeDetails2Returns.result1, fake.getBlockVolumeDetails2Returns.result2, fake.getBlockVolumeDetails2Returns.result3
}

func (fake *FakeClient) GetBlockVolumeDetails2CallCount() int {
	fake.getBlockVolumeDetails2Mutex.RLock()
	defer fake.getBlockVolumeDetails2Mutex.RUnlock()
	return len(fake.getBlockVolumeDetails2ArgsForCall)
}

func (fake *FakeClient) GetBlockVolumeDetails2ArgsForCall(i int) (int, string) {
	fake.getBlockVolumeDetails2Mutex.RLock()
	defer fake.getBlockVolumeDetails2Mutex.RUnlock()
	return fake.getBlockVolumeDetails2ArgsForCall[i].volumeId, fake.getBlockVolumeDetails2ArgsForCall[i].mask
}

func (fake *FakeClient) GetBlockVolumeDetails2Returns(result1 datatypes.Network_Storage, result2 bool, result3 error) {
	fake.GetBlockVolumeDetails2Stub = nil
	fake.getBlockVolumeDetails2Returns = struct {
		result1 datatypes.Network_Storage
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetBlockVolumeDetails2ReturnsOnCall(i int, result1 datatypes.Network_Storage, result2 bool, result3 error) {
	fake.GetBlockVolumeDetails2Stub = nil
	if fake.getBlockVolumeDetails2ReturnsOnCall == nil {
		fake.getBlockVolumeDetails2ReturnsOnCall = make(map[int]struct {
			result1 datatypes.Network_Storage
			result2 bool
			result3 error
		})
	}
	fake.getBlockVolumeDetails2ReturnsOnCall[i] = struct {
		result1 datatypes.Network_Storage
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetNetworkStorageTarget(volumeId int, mask string) (string, bool, error) {
	fake.getNetworkStorageTargetMutex.Lock()
	ret, specificReturn := fake.getNetworkStorageTargetReturnsOnCall[len(fake.getNetworkStorageTargetArgsForCall)]
	fake.getNetworkStorageTargetArgsForCall = append(fake.getNetworkStorageTargetArgsForCall, struct {
		volumeId int
		mask     string
	}{volumeId, mask})
	fake.recordInvocation("GetNetworkStorageTarget", []interface{}{volumeId, mask})
	fake.getNetworkStorageTargetMutex.Unlock()
	if fake.GetNetworkStorageTargetStub != nil {
		return fake.GetNetworkStorageTargetStub(volumeId, mask)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.getNetworkStorageTargetReturns.result1, fake.getNetworkStorageTargetReturns.result2, fake.getNetworkStorageTargetReturns.result3
}

func (fake *FakeClient) GetNetworkStorageTargetCallCount() int {
	fake.getNetworkStorageTargetMutex.RLock()
	defer fake.getNetworkStorageTargetMutex.RUnlock()
	return len(fake.getNetworkStorageTargetArgsForCall)
}

func (fake *FakeClient) GetNetworkStorageTargetArgsForCall(i int) (int, string) {
	fake.getNetworkStorageTargetMutex.RLock()
	defer fake.getNetworkStorageTargetMutex.RUnlock()
	return fake.getNetworkStorageTargetArgsForCall[i].volumeId, fake.getNetworkStorageTargetArgsForCall[i].mask
}

func (fake *FakeClient) GetNetworkStorageTargetReturns(result1 string, result2 bool, result3 error) {
	fake.GetNetworkStorageTargetStub = nil
	fake.getNetworkStorageTargetReturns = struct {
		result1 string
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetNetworkStorageTargetReturnsOnCall(i int, result1 string, result2 bool, result3 error) {
	fake.GetNetworkStorageTargetStub = nil
	if fake.getNetworkStorageTargetReturnsOnCall == nil {
		fake.getNetworkStorageTargetReturnsOnCall = make(map[int]struct {
			result1 string
			result2 bool
			result3 error
		})
	}
	fake.getNetworkStorageTargetReturnsOnCall[i] = struct {
		result1 string
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetImage(imageId int, mask string) (*datatypes.Virtual_Guest_Block_Device_Template_Group, bool, error) {
	fake.getImageMutex.Lock()
	ret, specificReturn := fake.getImageReturnsOnCall[len(fake.getImageArgsForCall)]
	fake.getImageArgsForCall = append(fake.getImageArgsForCall, struct {
		imageId int
		mask    string
	}{imageId, mask})
	fake.recordInvocation("GetImage", []interface{}{imageId, mask})
	fake.getImageMutex.Unlock()
	if fake.GetImageStub != nil {
		return fake.GetImageStub(imageId, mask)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.getImageReturns.result1, fake.getImageReturns.result2, fake.getImageReturns.result3
}

func (fake *FakeClient) GetImageCallCount() int {
	fake.getImageMutex.RLock()
	defer fake.getImageMutex.RUnlock()
	return len(fake.getImageArgsForCall)
}

func (fake *FakeClient) GetImageArgsForCall(i int) (int, string) {
	fake.getImageMutex.RLock()
	defer fake.getImageMutex.RUnlock()
	return fake.getImageArgsForCall[i].imageId, fake.getImageArgsForCall[i].mask
}

func (fake *FakeClient) GetImageReturns(result1 *datatypes.Virtual_Guest_Block_Device_Template_Group, result2 bool, result3 error) {
	fake.GetImageStub = nil
	fake.getImageReturns = struct {
		result1 *datatypes.Virtual_Guest_Block_Device_Template_Group
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetImageReturnsOnCall(i int, result1 *datatypes.Virtual_Guest_Block_Device_Template_Group, result2 bool, result3 error) {
	fake.GetImageStub = nil
	if fake.getImageReturnsOnCall == nil {
		fake.getImageReturnsOnCall = make(map[int]struct {
			result1 *datatypes.Virtual_Guest_Block_Device_Template_Group
			result2 bool
			result3 error
		})
	}
	fake.getImageReturnsOnCall[i] = struct {
		result1 *datatypes.Virtual_Guest_Block_Device_Template_Group
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetVlan(id int, mask string) (*datatypes.Network_Vlan, bool, error) {
	fake.getVlanMutex.Lock()
	ret, specificReturn := fake.getVlanReturnsOnCall[len(fake.getVlanArgsForCall)]
	fake.getVlanArgsForCall = append(fake.getVlanArgsForCall, struct {
		id   int
		mask string
	}{id, mask})
	fake.recordInvocation("GetVlan", []interface{}{id, mask})
	fake.getVlanMutex.Unlock()
	if fake.GetVlanStub != nil {
		return fake.GetVlanStub(id, mask)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.getVlanReturns.result1, fake.getVlanReturns.result2, fake.getVlanReturns.result3
}

func (fake *FakeClient) GetVlanCallCount() int {
	fake.getVlanMutex.RLock()
	defer fake.getVlanMutex.RUnlock()
	return len(fake.getVlanArgsForCall)
}

func (fake *FakeClient) GetVlanArgsForCall(i int) (int, string) {
	fake.getVlanMutex.RLock()
	defer fake.getVlanMutex.RUnlock()
	return fake.getVlanArgsForCall[i].id, fake.getVlanArgsForCall[i].mask
}

func (fake *FakeClient) GetVlanReturns(result1 *datatypes.Network_Vlan, result2 bool, result3 error) {
	fake.GetVlanStub = nil
	fake.getVlanReturns = struct {
		result1 *datatypes.Network_Vlan
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetVlanReturnsOnCall(i int, result1 *datatypes.Network_Vlan, result2 bool, result3 error) {
	fake.GetVlanStub = nil
	if fake.getVlanReturnsOnCall == nil {
		fake.getVlanReturnsOnCall = make(map[int]struct {
			result1 *datatypes.Network_Vlan
			result2 bool
			result3 error
		})
	}
	fake.getVlanReturnsOnCall[i] = struct {
		result1 *datatypes.Network_Vlan
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetAllowedHostCredential(id int) (*datatypes.Network_Storage_Allowed_Host, bool, error) {
	fake.getAllowedHostCredentialMutex.Lock()
	ret, specificReturn := fake.getAllowedHostCredentialReturnsOnCall[len(fake.getAllowedHostCredentialArgsForCall)]
	fake.getAllowedHostCredentialArgsForCall = append(fake.getAllowedHostCredentialArgsForCall, struct {
		id int
	}{id})
	fake.recordInvocation("GetAllowedHostCredential", []interface{}{id})
	fake.getAllowedHostCredentialMutex.Unlock()
	if fake.GetAllowedHostCredentialStub != nil {
		return fake.GetAllowedHostCredentialStub(id)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.getAllowedHostCredentialReturns.result1, fake.getAllowedHostCredentialReturns.result2, fake.getAllowedHostCredentialReturns.result3
}

func (fake *FakeClient) GetAllowedHostCredentialCallCount() int {
	fake.getAllowedHostCredentialMutex.RLock()
	defer fake.getAllowedHostCredentialMutex.RUnlock()
	return len(fake.getAllowedHostCredentialArgsForCall)
}

func (fake *FakeClient) GetAllowedHostCredentialArgsForCall(i int) int {
	fake.getAllowedHostCredentialMutex.RLock()
	defer fake.getAllowedHostCredentialMutex.RUnlock()
	return fake.getAllowedHostCredentialArgsForCall[i].id
}

func (fake *FakeClient) GetAllowedHostCredentialReturns(result1 *datatypes.Network_Storage_Allowed_Host, result2 bool, result3 error) {
	fake.GetAllowedHostCredentialStub = nil
	fake.getAllowedHostCredentialReturns = struct {
		result1 *datatypes.Network_Storage_Allowed_Host
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetAllowedHostCredentialReturnsOnCall(i int, result1 *datatypes.Network_Storage_Allowed_Host, result2 bool, result3 error) {
	fake.GetAllowedHostCredentialStub = nil
	if fake.getAllowedHostCredentialReturnsOnCall == nil {
		fake.getAllowedHostCredentialReturnsOnCall = make(map[int]struct {
			result1 *datatypes.Network_Storage_Allowed_Host
			result2 bool
			result3 error
		})
	}
	fake.getAllowedHostCredentialReturnsOnCall[i] = struct {
		result1 *datatypes.Network_Storage_Allowed_Host
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetAllowedNetworkStorage(id int) ([]string, bool, error) {
	fake.getAllowedNetworkStorageMutex.Lock()
	ret, specificReturn := fake.getAllowedNetworkStorageReturnsOnCall[len(fake.getAllowedNetworkStorageArgsForCall)]
	fake.getAllowedNetworkStorageArgsForCall = append(fake.getAllowedNetworkStorageArgsForCall, struct {
		id int
	}{id})
	fake.recordInvocation("GetAllowedNetworkStorage", []interface{}{id})
	fake.getAllowedNetworkStorageMutex.Unlock()
	if fake.GetAllowedNetworkStorageStub != nil {
		return fake.GetAllowedNetworkStorageStub(id)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.getAllowedNetworkStorageReturns.result1, fake.getAllowedNetworkStorageReturns.result2, fake.getAllowedNetworkStorageReturns.result3
}

func (fake *FakeClient) GetAllowedNetworkStorageCallCount() int {
	fake.getAllowedNetworkStorageMutex.RLock()
	defer fake.getAllowedNetworkStorageMutex.RUnlock()
	return len(fake.getAllowedNetworkStorageArgsForCall)
}

func (fake *FakeClient) GetAllowedNetworkStorageArgsForCall(i int) int {
	fake.getAllowedNetworkStorageMutex.RLock()
	defer fake.getAllowedNetworkStorageMutex.RUnlock()
	return fake.getAllowedNetworkStorageArgsForCall[i].id
}

func (fake *FakeClient) GetAllowedNetworkStorageReturns(result1 []string, result2 bool, result3 error) {
	fake.GetAllowedNetworkStorageStub = nil
	fake.getAllowedNetworkStorageReturns = struct {
		result1 []string
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetAllowedNetworkStorageReturnsOnCall(i int, result1 []string, result2 bool, result3 error) {
	fake.GetAllowedNetworkStorageStub = nil
	if fake.getAllowedNetworkStorageReturnsOnCall == nil {
		fake.getAllowedNetworkStorageReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 bool
			result3 error
		})
	}
	fake.getAllowedNetworkStorageReturnsOnCall[i] = struct {
		result1 []string
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) CreateSshKey(label *string, key *string, fingerPrint *string) (*datatypes.Security_Ssh_Key, error) {
	fake.createSshKeyMutex.Lock()
	ret, specificReturn := fake.createSshKeyReturnsOnCall[len(fake.createSshKeyArgsForCall)]
	fake.createSshKeyArgsForCall = append(fake.createSshKeyArgsForCall, struct {
		label       *string
		key         *string
		fingerPrint *string
	}{label, key, fingerPrint})
	fake.recordInvocation("CreateSshKey", []interface{}{label, key, fingerPrint})
	fake.createSshKeyMutex.Unlock()
	if fake.CreateSshKeyStub != nil {
		return fake.CreateSshKeyStub(label, key, fingerPrint)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createSshKeyReturns.result1, fake.createSshKeyReturns.result2
}

func (fake *FakeClient) CreateSshKeyCallCount() int {
	fake.createSshKeyMutex.RLock()
	defer fake.createSshKeyMutex.RUnlock()
	return len(fake.createSshKeyArgsForCall)
}

func (fake *FakeClient) CreateSshKeyArgsForCall(i int) (*string, *string, *string) {
	fake.createSshKeyMutex.RLock()
	defer fake.createSshKeyMutex.RUnlock()
	return fake.createSshKeyArgsForCall[i].label, fake.createSshKeyArgsForCall[i].key, fake.createSshKeyArgsForCall[i].fingerPrint
}

func (fake *FakeClient) CreateSshKeyReturns(result1 *datatypes.Security_Ssh_Key, result2 error) {
	fake.CreateSshKeyStub = nil
	fake.createSshKeyReturns = struct {
		result1 *datatypes.Security_Ssh_Key
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateSshKeyReturnsOnCall(i int, result1 *datatypes.Security_Ssh_Key, result2 error) {
	fake.CreateSshKeyStub = nil
	if fake.createSshKeyReturnsOnCall == nil {
		fake.createSshKeyReturnsOnCall = make(map[int]struct {
			result1 *datatypes.Security_Ssh_Key
			result2 error
		})
	}
	fake.createSshKeyReturnsOnCall[i] = struct {
		result1 *datatypes.Security_Ssh_Key
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DeleteSshKey(id int) (bool, error) {
	fake.deleteSshKeyMutex.Lock()
	ret, specificReturn := fake.deleteSshKeyReturnsOnCall[len(fake.deleteSshKeyArgsForCall)]
	fake.deleteSshKeyArgsForCall = append(fake.deleteSshKeyArgsForCall, struct {
		id int
	}{id})
	fake.recordInvocation("DeleteSshKey", []interface{}{id})
	fake.deleteSshKeyMutex.Unlock()
	if fake.DeleteSshKeyStub != nil {
		return fake.DeleteSshKeyStub(id)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.deleteSshKeyReturns.result1, fake.deleteSshKeyReturns.result2
}

func (fake *FakeClient) DeleteSshKeyCallCount() int {
	fake.deleteSshKeyMutex.RLock()
	defer fake.deleteSshKeyMutex.RUnlock()
	return len(fake.deleteSshKeyArgsForCall)
}

func (fake *FakeClient) DeleteSshKeyArgsForCall(i int) int {
	fake.deleteSshKeyMutex.RLock()
	defer fake.deleteSshKeyMutex.RUnlock()
	return fake.deleteSshKeyArgsForCall[i].id
}

func (fake *FakeClient) DeleteSshKeyReturns(result1 bool, result2 error) {
	fake.DeleteSshKeyStub = nil
	fake.deleteSshKeyReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DeleteSshKeyReturnsOnCall(i int, result1 bool, result2 error) {
	fake.DeleteSshKeyStub = nil
	if fake.deleteSshKeyReturnsOnCall == nil {
		fake.deleteSshKeyReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.deleteSshKeyReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateInstanceFromVPS(template *datatypes.Virtual_Guest, stemcellID int, sshKeys []int) (*datatypes.Virtual_Guest, error) {
	var sshKeysCopy []int
	if sshKeys != nil {
		sshKeysCopy = make([]int, len(sshKeys))
		copy(sshKeysCopy, sshKeys)
	}
	fake.createInstanceFromVPSMutex.Lock()
	ret, specificReturn := fake.createInstanceFromVPSReturnsOnCall[len(fake.createInstanceFromVPSArgsForCall)]
	fake.createInstanceFromVPSArgsForCall = append(fake.createInstanceFromVPSArgsForCall, struct {
		template   *datatypes.Virtual_Guest
		stemcellID int
		sshKeys    []int
	}{template, stemcellID, sshKeysCopy})
	fake.recordInvocation("CreateInstanceFromVPS", []interface{}{template, stemcellID, sshKeysCopy})
	fake.createInstanceFromVPSMutex.Unlock()
	if fake.CreateInstanceFromVPSStub != nil {
		return fake.CreateInstanceFromVPSStub(template, stemcellID, sshKeys)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createInstanceFromVPSReturns.result1, fake.createInstanceFromVPSReturns.result2
}

func (fake *FakeClient) CreateInstanceFromVPSCallCount() int {
	fake.createInstanceFromVPSMutex.RLock()
	defer fake.createInstanceFromVPSMutex.RUnlock()
	return len(fake.createInstanceFromVPSArgsForCall)
}

func (fake *FakeClient) CreateInstanceFromVPSArgsForCall(i int) (*datatypes.Virtual_Guest, int, []int) {
	fake.createInstanceFromVPSMutex.RLock()
	defer fake.createInstanceFromVPSMutex.RUnlock()
	return fake.createInstanceFromVPSArgsForCall[i].template, fake.createInstanceFromVPSArgsForCall[i].stemcellID, fake.createInstanceFromVPSArgsForCall[i].sshKeys
}

func (fake *FakeClient) CreateInstanceFromVPSReturns(result1 *datatypes.Virtual_Guest, result2 error) {
	fake.CreateInstanceFromVPSStub = nil
	fake.createInstanceFromVPSReturns = struct {
		result1 *datatypes.Virtual_Guest
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateInstanceFromVPSReturnsOnCall(i int, result1 *datatypes.Virtual_Guest, result2 error) {
	fake.CreateInstanceFromVPSStub = nil
	if fake.createInstanceFromVPSReturnsOnCall == nil {
		fake.createInstanceFromVPSReturnsOnCall = make(map[int]struct {
			result1 *datatypes.Virtual_Guest
			result2 error
		})
	}
	fake.createInstanceFromVPSReturnsOnCall[i] = struct {
		result1 *datatypes.Virtual_Guest
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DeleteInstanceFromVPS(id int) error {
	fake.deleteInstanceFromVPSMutex.Lock()
	ret, specificReturn := fake.deleteInstanceFromVPSReturnsOnCall[len(fake.deleteInstanceFromVPSArgsForCall)]
	fake.deleteInstanceFromVPSArgsForCall = append(fake.deleteInstanceFromVPSArgsForCall, struct {
		id int
	}{id})
	fake.recordInvocation("DeleteInstanceFromVPS", []interface{}{id})
	fake.deleteInstanceFromVPSMutex.Unlock()
	if fake.DeleteInstanceFromVPSStub != nil {
		return fake.DeleteInstanceFromVPSStub(id)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteInstanceFromVPSReturns.result1
}

func (fake *FakeClient) DeleteInstanceFromVPSCallCount() int {
	fake.deleteInstanceFromVPSMutex.RLock()
	defer fake.deleteInstanceFromVPSMutex.RUnlock()
	return len(fake.deleteInstanceFromVPSArgsForCall)
}

func (fake *FakeClient) DeleteInstanceFromVPSArgsForCall(i int) int {
	fake.deleteInstanceFromVPSMutex.RLock()
	defer fake.deleteInstanceFromVPSMutex.RUnlock()
	return fake.deleteInstanceFromVPSArgsForCall[i].id
}

func (fake *FakeClient) DeleteInstanceFromVPSReturns(result1 error) {
	fake.DeleteInstanceFromVPSStub = nil
	fake.deleteInstanceFromVPSReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeleteInstanceFromVPSReturnsOnCall(i int, result1 error) {
	fake.DeleteInstanceFromVPSStub = nil
	if fake.deleteInstanceFromVPSReturnsOnCall == nil {
		fake.deleteInstanceFromVPSReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteInstanceFromVPSReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.cancelInstanceMutex.RLock()
	defer fake.cancelInstanceMutex.RUnlock()
	fake.createInstanceMutex.RLock()
	defer fake.createInstanceMutex.RUnlock()
	fake.editInstanceMutex.RLock()
	defer fake.editInstanceMutex.RUnlock()
	fake.getInstanceMutex.RLock()
	defer fake.getInstanceMutex.RUnlock()
	fake.getInstanceByPrimaryBackendIpAddressMutex.RLock()
	defer fake.getInstanceByPrimaryBackendIpAddressMutex.RUnlock()
	fake.getInstanceByPrimaryIpAddressMutex.RLock()
	defer fake.getInstanceByPrimaryIpAddressMutex.RUnlock()
	fake.rebootInstanceMutex.RLock()
	defer fake.rebootInstanceMutex.RUnlock()
	fake.reloadInstanceMutex.RLock()
	defer fake.reloadInstanceMutex.RUnlock()
	fake.upgradeInstanceConfigMutex.RLock()
	defer fake.upgradeInstanceConfigMutex.RUnlock()
	fake.upgradeInstanceMutex.RLock()
	defer fake.upgradeInstanceMutex.RUnlock()
	fake.waitInstanceUntilReadyMutex.RLock()
	defer fake.waitInstanceUntilReadyMutex.RUnlock()
	fake.waitInstanceHasActiveTransactionMutex.RLock()
	defer fake.waitInstanceHasActiveTransactionMutex.RUnlock()
	fake.waitInstanceHasNoneActiveTransactionMutex.RLock()
	defer fake.waitInstanceHasNoneActiveTransactionMutex.RUnlock()
	fake.waitVolumeProvisioningWithOrderIdMutex.RLock()
	defer fake.waitVolumeProvisioningWithOrderIdMutex.RUnlock()
	fake.setTagsMutex.RLock()
	defer fake.setTagsMutex.RUnlock()
	fake.attachSecondDiskToInstanceMutex.RLock()
	defer fake.attachSecondDiskToInstanceMutex.RUnlock()
	fake.getInstanceAllowedHostMutex.RLock()
	defer fake.getInstanceAllowedHostMutex.RUnlock()
	fake.authorizeHostToVolumeMutex.RLock()
	defer fake.authorizeHostToVolumeMutex.RUnlock()
	fake.deauthorizeHostToVolumeMutex.RLock()
	defer fake.deauthorizeHostToVolumeMutex.RUnlock()
	fake.createVolumeMutex.RLock()
	defer fake.createVolumeMutex.RUnlock()
	fake.orderBlockVolumeMutex.RLock()
	defer fake.orderBlockVolumeMutex.RUnlock()
	fake.cancelBlockVolumeMutex.RLock()
	defer fake.cancelBlockVolumeMutex.RUnlock()
	fake.getBlockVolumeDetailsMutex.RLock()
	defer fake.getBlockVolumeDetailsMutex.RUnlock()
	fake.getBlockVolumeDetails2Mutex.RLock()
	defer fake.getBlockVolumeDetails2Mutex.RUnlock()
	fake.getNetworkStorageTargetMutex.RLock()
	defer fake.getNetworkStorageTargetMutex.RUnlock()
	fake.getImageMutex.RLock()
	defer fake.getImageMutex.RUnlock()
	fake.getVlanMutex.RLock()
	defer fake.getVlanMutex.RUnlock()
	fake.getAllowedHostCredentialMutex.RLock()
	defer fake.getAllowedHostCredentialMutex.RUnlock()
	fake.getAllowedNetworkStorageMutex.RLock()
	defer fake.getAllowedNetworkStorageMutex.RUnlock()
	fake.createSshKeyMutex.RLock()
	defer fake.createSshKeyMutex.RUnlock()
	fake.deleteSshKeyMutex.RLock()
	defer fake.deleteSshKeyMutex.RUnlock()
	fake.createInstanceFromVPSMutex.RLock()
	defer fake.createInstanceFromVPSMutex.RUnlock()
	fake.deleteInstanceFromVPSMutex.RLock()
	defer fake.deleteInstanceFromVPSMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ client.Client = new(FakeClient)
