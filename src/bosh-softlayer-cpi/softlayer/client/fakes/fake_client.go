// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"bosh-softlayer-cpi/softlayer/client"
	"sync"
	"time"

	"github.com/softlayer/softlayer-go/datatypes"
)

type FakeClient struct {
	CancelInstanceStub        func(id int) error
	cancelInstanceMutex       sync.RWMutex
	cancelInstanceArgsForCall []struct {
		id int
	}
	cancelInstanceReturns struct {
		result1 error
	}
	cancelInstanceReturnsOnCall map[int]struct {
		result1 error
	}
	CreateInstanceStub        func(template *datatypes.Virtual_Guest) (*datatypes.Virtual_Guest, error)
	createInstanceMutex       sync.RWMutex
	createInstanceArgsForCall []struct {
		template *datatypes.Virtual_Guest
	}
	createInstanceReturns struct {
		result1 *datatypes.Virtual_Guest
		result2 error
	}
	createInstanceReturnsOnCall map[int]struct {
		result1 *datatypes.Virtual_Guest
		result2 error
	}
	EditInstanceStub        func(id int, template *datatypes.Virtual_Guest) (bool, error)
	editInstanceMutex       sync.RWMutex
	editInstanceArgsForCall []struct {
		id       int
		template *datatypes.Virtual_Guest
	}
	editInstanceReturns struct {
		result1 bool
		result2 error
	}
	editInstanceReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	GetInstanceStub        func(id int, mask string) (*datatypes.Virtual_Guest, bool, error)
	getInstanceMutex       sync.RWMutex
	getInstanceArgsForCall []struct {
		id   int
		mask string
	}
	getInstanceReturns struct {
		result1 *datatypes.Virtual_Guest
		result2 bool
		result3 error
	}
	getInstanceReturnsOnCall map[int]struct {
		result1 *datatypes.Virtual_Guest
		result2 bool
		result3 error
	}
	GetInstanceByPrimaryBackendIpAddressStub        func(ip string) (*datatypes.Virtual_Guest, bool, error)
	getInstanceByPrimaryBackendIpAddressMutex       sync.RWMutex
	getInstanceByPrimaryBackendIpAddressArgsForCall []struct {
		ip string
	}
	getInstanceByPrimaryBackendIpAddressReturns struct {
		result1 *datatypes.Virtual_Guest
		result2 bool
		result3 error
	}
	getInstanceByPrimaryBackendIpAddressReturnsOnCall map[int]struct {
		result1 *datatypes.Virtual_Guest
		result2 bool
		result3 error
	}
	GetInstanceByPrimaryIpAddressStub        func(ip string) (*datatypes.Virtual_Guest, bool, error)
	getInstanceByPrimaryIpAddressMutex       sync.RWMutex
	getInstanceByPrimaryIpAddressArgsForCall []struct {
		ip string
	}
	getInstanceByPrimaryIpAddressReturns struct {
		result1 *datatypes.Virtual_Guest
		result2 bool
		result3 error
	}
	getInstanceByPrimaryIpAddressReturnsOnCall map[int]struct {
		result1 *datatypes.Virtual_Guest
		result2 bool
		result3 error
	}
	RebootInstanceStub        func(id int, soft bool, hard bool) error
	rebootInstanceMutex       sync.RWMutex
	rebootInstanceArgsForCall []struct {
		id   int
		soft bool
		hard bool
	}
	rebootInstanceReturns struct {
		result1 error
	}
	rebootInstanceReturnsOnCall map[int]struct {
		result1 error
	}
	ReloadInstanceStub        func(id int, stemcellId int, sshKeyIds []int, hostname string, domain string) error
	reloadInstanceMutex       sync.RWMutex
	reloadInstanceArgsForCall []struct {
		id         int
		stemcellId int
		sshKeyIds  []int
		hostname   string
		domain     string
	}
	reloadInstanceReturns struct {
		result1 error
	}
	reloadInstanceReturnsOnCall map[int]struct {
		result1 error
	}
	UpgradeInstanceConfigStub        func(id int, cpu int, memory int, network int, privateCPU bool) error
	upgradeInstanceConfigMutex       sync.RWMutex
	upgradeInstanceConfigArgsForCall []struct {
		id         int
		cpu        int
		memory     int
		network    int
		privateCPU bool
	}
	upgradeInstanceConfigReturns struct {
		result1 error
	}
	upgradeInstanceConfigReturnsOnCall map[int]struct {
		result1 error
	}
	UpgradeInstanceStub        func(id int, cpu int, memory int, network int, privateCPU bool, secondDiskSize int) (int, error)
	upgradeInstanceMutex       sync.RWMutex
	upgradeInstanceArgsForCall []struct {
		id             int
		cpu            int
		memory         int
		network        int
		privateCPU     bool
		secondDiskSize int
	}
	upgradeInstanceReturns struct {
		result1 int
		result2 error
	}
	upgradeInstanceReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	WaitInstanceUntilReadyStub        func(id int, until time.Time) error
	waitInstanceUntilReadyMutex       sync.RWMutex
	waitInstanceUntilReadyArgsForCall []struct {
		id    int
		until time.Time
	}
	waitInstanceUntilReadyReturns struct {
		result1 error
	}
	waitInstanceUntilReadyReturnsOnCall map[int]struct {
		result1 error
	}
	WaitInstanceUntilReadyWithTicketStub        func(id int, until time.Time) error
	waitInstanceUntilReadyWithTicketMutex       sync.RWMutex
	waitInstanceUntilReadyWithTicketArgsForCall []struct {
		id    int
		until time.Time
	}
	waitInstanceUntilReadyWithTicketReturns struct {
		result1 error
	}
	waitInstanceUntilReadyWithTicketReturnsOnCall map[int]struct {
		result1 error
	}
	WaitInstanceHasActiveTransactionStub        func(id int, until time.Time) error
	waitInstanceHasActiveTransactionMutex       sync.RWMutex
	waitInstanceHasActiveTransactionArgsForCall []struct {
		id    int
		until time.Time
	}
	waitInstanceHasActiveTransactionReturns struct {
		result1 error
	}
	waitInstanceHasActiveTransactionReturnsOnCall map[int]struct {
		result1 error
	}
	WaitInstanceHasNoneActiveTransactionStub        func(id int, until time.Time) error
	waitInstanceHasNoneActiveTransactionMutex       sync.RWMutex
	waitInstanceHasNoneActiveTransactionArgsForCall []struct {
		id    int
		until time.Time
	}
	waitInstanceHasNoneActiveTransactionReturns struct {
		result1 error
	}
	waitInstanceHasNoneActiveTransactionReturnsOnCall map[int]struct {
		result1 error
	}
	WaitVolumeProvisioningWithOrderIdStub        func(orderId int, until time.Time) (*datatypes.Network_Storage, error)
	waitVolumeProvisioningWithOrderIdMutex       sync.RWMutex
	waitVolumeProvisioningWithOrderIdArgsForCall []struct {
		orderId int
		until   time.Time
	}
	waitVolumeProvisioningWithOrderIdReturns struct {
		result1 *datatypes.Network_Storage
		result2 error
	}
	waitVolumeProvisioningWithOrderIdReturnsOnCall map[int]struct {
		result1 *datatypes.Network_Storage
		result2 error
	}
	SetTagsStub        func(id int, tags string) (bool, error)
	setTagsMutex       sync.RWMutex
	setTagsArgsForCall []struct {
		id   int
		tags string
	}
	setTagsReturns struct {
		result1 bool
		result2 error
	}
	setTagsReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	SetInstanceMetadataStub        func(id int, userData *string) (bool, error)
	setInstanceMetadataMutex       sync.RWMutex
	setInstanceMetadataArgsForCall []struct {
		id       int
		userData *string
	}
	setInstanceMetadataReturns struct {
		result1 bool
		result2 error
	}
	setInstanceMetadataReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	AttachSecondDiskToInstanceStub        func(id int, diskSize int) error
	attachSecondDiskToInstanceMutex       sync.RWMutex
	attachSecondDiskToInstanceArgsForCall []struct {
		id       int
		diskSize int
	}
	attachSecondDiskToInstanceReturns struct {
		result1 error
	}
	attachSecondDiskToInstanceReturnsOnCall map[int]struct {
		result1 error
	}
	GetInstanceAllowedHostStub        func(id int) (*datatypes.Network_Storage_Allowed_Host, bool, error)
	getInstanceAllowedHostMutex       sync.RWMutex
	getInstanceAllowedHostArgsForCall []struct {
		id int
	}
	getInstanceAllowedHostReturns struct {
		result1 *datatypes.Network_Storage_Allowed_Host
		result2 bool
		result3 error
	}
	getInstanceAllowedHostReturnsOnCall map[int]struct {
		result1 *datatypes.Network_Storage_Allowed_Host
		result2 bool
		result3 error
	}
	AuthorizeHostToVolumeStub        func(instance *datatypes.Virtual_Guest, volumeId int, until time.Time) (bool, error)
	authorizeHostToVolumeMutex       sync.RWMutex
	authorizeHostToVolumeArgsForCall []struct {
		instance *datatypes.Virtual_Guest
		volumeId int
		until    time.Time
	}
	authorizeHostToVolumeReturns struct {
		result1 bool
		result2 error
	}
	authorizeHostToVolumeReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	DeauthorizeHostToVolumeStub        func(instance *datatypes.Virtual_Guest, volumeId int, until time.Time) (bool, error)
	deauthorizeHostToVolumeMutex       sync.RWMutex
	deauthorizeHostToVolumeArgsForCall []struct {
		instance *datatypes.Virtual_Guest
		volumeId int
		until    time.Time
	}
	deauthorizeHostToVolumeReturns struct {
		result1 bool
		result2 error
	}
	deauthorizeHostToVolumeReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	CreateVolumeStub        func(location string, size int, iops int, snapshotSpace int) (*datatypes.Network_Storage, error)
	createVolumeMutex       sync.RWMutex
	createVolumeArgsForCall []struct {
		location      string
		size          int
		iops          int
		snapshotSpace int
	}
	createVolumeReturns struct {
		result1 *datatypes.Network_Storage
		result2 error
	}
	createVolumeReturnsOnCall map[int]struct {
		result1 *datatypes.Network_Storage
		result2 error
	}
	OrderBlockVolumeStub        func(storageType string, location string, size int, iops int) (*datatypes.Container_Product_Order_Receipt, error)
	orderBlockVolumeMutex       sync.RWMutex
	orderBlockVolumeArgsForCall []struct {
		storageType string
		location    string
		size        int
		iops        int
	}
	orderBlockVolumeReturns struct {
		result1 *datatypes.Container_Product_Order_Receipt
		result2 error
	}
	orderBlockVolumeReturnsOnCall map[int]struct {
		result1 *datatypes.Container_Product_Order_Receipt
		result2 error
	}
	OrderBlockVolume2Stub        func(storageType string, location string, size int, iops int, snapshotSpace int) (*datatypes.Container_Product_Order_Receipt, error)
	orderBlockVolume2Mutex       sync.RWMutex
	orderBlockVolume2ArgsForCall []struct {
		storageType   string
		location      string
		size          int
		iops          int
		snapshotSpace int
	}
	orderBlockVolume2Returns struct {
		result1 *datatypes.Container_Product_Order_Receipt
		result2 error
	}
	orderBlockVolume2ReturnsOnCall map[int]struct {
		result1 *datatypes.Container_Product_Order_Receipt
		result2 error
	}
	CancelBlockVolumeStub        func(volumeId int, reason string, immediate bool) (bool, error)
	cancelBlockVolumeMutex       sync.RWMutex
	cancelBlockVolumeArgsForCall []struct {
		volumeId  int
		reason    string
		immediate bool
	}
	cancelBlockVolumeReturns struct {
		result1 bool
		result2 error
	}
	cancelBlockVolumeReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	GetBlockVolumeDetailsStub        func(volumeId int, mask string) (*datatypes.Network_Storage, bool, error)
	getBlockVolumeDetailsMutex       sync.RWMutex
	getBlockVolumeDetailsArgsForCall []struct {
		volumeId int
		mask     string
	}
	getBlockVolumeDetailsReturns struct {
		result1 *datatypes.Network_Storage
		result2 bool
		result3 error
	}
	getBlockVolumeDetailsReturnsOnCall map[int]struct {
		result1 *datatypes.Network_Storage
		result2 bool
		result3 error
	}
	GetBlockVolumeDetailsBySoftLayerAccountStub        func(volumeId int, mask string) (datatypes.Network_Storage, error)
	getBlockVolumeDetailsBySoftLayerAccountMutex       sync.RWMutex
	getBlockVolumeDetailsBySoftLayerAccountArgsForCall []struct {
		volumeId int
		mask     string
	}
	getBlockVolumeDetailsBySoftLayerAccountReturns struct {
		result1 datatypes.Network_Storage
		result2 error
	}
	getBlockVolumeDetailsBySoftLayerAccountReturnsOnCall map[int]struct {
		result1 datatypes.Network_Storage
		result2 error
	}
	GetNetworkStorageTargetStub        func(volumeId int, mask string) (string, bool, error)
	getNetworkStorageTargetMutex       sync.RWMutex
	getNetworkStorageTargetArgsForCall []struct {
		volumeId int
		mask     string
	}
	getNetworkStorageTargetReturns struct {
		result1 string
		result2 bool
		result3 error
	}
	getNetworkStorageTargetReturnsOnCall map[int]struct {
		result1 string
		result2 bool
		result3 error
	}
	SetNotesStub        func(id int, notes string) (bool, error)
	setNotesMutex       sync.RWMutex
	setNotesArgsForCall []struct {
		id    int
		notes string
	}
	setNotesReturns struct {
		result1 bool
		result2 error
	}
	setNotesReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	GetImageStub        func(imageId int, mask string) (*datatypes.Virtual_Guest_Block_Device_Template_Group, bool, error)
	getImageMutex       sync.RWMutex
	getImageArgsForCall []struct {
		imageId int
		mask    string
	}
	getImageReturns struct {
		result1 *datatypes.Virtual_Guest_Block_Device_Template_Group
		result2 bool
		result3 error
	}
	getImageReturnsOnCall map[int]struct {
		result1 *datatypes.Virtual_Guest_Block_Device_Template_Group
		result2 bool
		result3 error
	}
	GetVlanStub        func(id int, mask string) (*datatypes.Network_Vlan, bool, error)
	getVlanMutex       sync.RWMutex
	getVlanArgsForCall []struct {
		id   int
		mask string
	}
	getVlanReturns struct {
		result1 *datatypes.Network_Vlan
		result2 bool
		result3 error
	}
	getVlanReturnsOnCall map[int]struct {
		result1 *datatypes.Network_Vlan
		result2 bool
		result3 error
	}
	GetSubnetStub        func(id int, mask string) (*datatypes.Network_Subnet, bool, error)
	getSubnetMutex       sync.RWMutex
	getSubnetArgsForCall []struct {
		id   int
		mask string
	}
	getSubnetReturns struct {
		result1 *datatypes.Network_Subnet
		result2 bool
		result3 error
	}
	getSubnetReturnsOnCall map[int]struct {
		result1 *datatypes.Network_Subnet
		result2 bool
		result3 error
	}
	GetAllowedHostCredentialStub        func(id int) (*datatypes.Network_Storage_Allowed_Host, bool, error)
	getAllowedHostCredentialMutex       sync.RWMutex
	getAllowedHostCredentialArgsForCall []struct {
		id int
	}
	getAllowedHostCredentialReturns struct {
		result1 *datatypes.Network_Storage_Allowed_Host
		result2 bool
		result3 error
	}
	getAllowedHostCredentialReturnsOnCall map[int]struct {
		result1 *datatypes.Network_Storage_Allowed_Host
		result2 bool
		result3 error
	}
	GetAllowedNetworkStorageStub        func(id int) ([]string, bool, error)
	getAllowedNetworkStorageMutex       sync.RWMutex
	getAllowedNetworkStorageArgsForCall []struct {
		id int
	}
	getAllowedNetworkStorageReturns struct {
		result1 []string
		result2 bool
		result3 error
	}
	getAllowedNetworkStorageReturnsOnCall map[int]struct {
		result1 []string
		result2 bool
		result3 error
	}
	CreateSshKeyStub        func(label *string, key *string, fingerPrint *string) (*datatypes.Security_Ssh_Key, error)
	createSshKeyMutex       sync.RWMutex
	createSshKeyArgsForCall []struct {
		label       *string
		key         *string
		fingerPrint *string
	}
	createSshKeyReturns struct {
		result1 *datatypes.Security_Ssh_Key
		result2 error
	}
	createSshKeyReturnsOnCall map[int]struct {
		result1 *datatypes.Security_Ssh_Key
		result2 error
	}
	DeleteSshKeyStub        func(id int) (bool, error)
	deleteSshKeyMutex       sync.RWMutex
	deleteSshKeyArgsForCall []struct {
		id int
	}
	deleteSshKeyReturns struct {
		result1 bool
		result2 error
	}
	deleteSshKeyReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	CreateInstanceFromVPSStub        func(template *datatypes.Virtual_Guest, stemcellID int, sshKeys []int) (*datatypes.Virtual_Guest, error)
	createInstanceFromVPSMutex       sync.RWMutex
	createInstanceFromVPSArgsForCall []struct {
		template   *datatypes.Virtual_Guest
		stemcellID int
		sshKeys    []int
	}
	createInstanceFromVPSReturns struct {
		result1 *datatypes.Virtual_Guest
		result2 error
	}
	createInstanceFromVPSReturnsOnCall map[int]struct {
		result1 *datatypes.Virtual_Guest
		result2 error
	}
	DeleteInstanceFromVPSStub        func(id int) error
	deleteInstanceFromVPSMutex       sync.RWMutex
	deleteInstanceFromVPSArgsForCall []struct {
		id int
	}
	deleteInstanceFromVPSReturns struct {
		result1 error
	}
	deleteInstanceFromVPSReturnsOnCall map[int]struct {
		result1 error
	}
	CreateSnapshotStub        func(volumeId int, notes string) (datatypes.Network_Storage, error)
	createSnapshotMutex       sync.RWMutex
	createSnapshotArgsForCall []struct {
		volumeId int
		notes    string
	}
	createSnapshotReturns struct {
		result1 datatypes.Network_Storage
		result2 error
	}
	createSnapshotReturnsOnCall map[int]struct {
		result1 datatypes.Network_Storage
		result2 error
	}
	DeleteSnapshotStub        func(snapshotId int) error
	deleteSnapshotMutex       sync.RWMutex
	deleteSnapshotArgsForCall []struct {
		snapshotId int
	}
	deleteSnapshotReturns struct {
		result1 error
	}
	deleteSnapshotReturnsOnCall map[int]struct {
		result1 error
	}
	CreateTicketStub        func(ticketSubject *string, ticketTitle *string, contents *string, attachmentId *int, attachmentType *string) error
	createTicketMutex       sync.RWMutex
	createTicketArgsForCall []struct {
		ticketSubject  *string
		ticketTitle    *string
		contents       *string
		attachmentId   *int
		attachmentType *string
	}
	createTicketReturns struct {
		result1 error
	}
	createTicketReturnsOnCall map[int]struct {
		result1 error
	}
	CreateSwiftContainerStub        func(containerName string) error
	createSwiftContainerMutex       sync.RWMutex
	createSwiftContainerArgsForCall []struct {
		containerName string
	}
	createSwiftContainerReturns struct {
		result1 error
	}
	createSwiftContainerReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteSwiftContainerStub        func(containerName string) error
	deleteSwiftContainerMutex       sync.RWMutex
	deleteSwiftContainerArgsForCall []struct {
		containerName string
	}
	deleteSwiftContainerReturns struct {
		result1 error
	}
	deleteSwiftContainerReturnsOnCall map[int]struct {
		result1 error
	}
	UploadSwiftLargeObjectStub        func(containerName string, objectName string, objectFile string) error
	uploadSwiftLargeObjectMutex       sync.RWMutex
	uploadSwiftLargeObjectArgsForCall []struct {
		containerName string
		objectName    string
		objectFile    string
	}
	uploadSwiftLargeObjectReturns struct {
		result1 error
	}
	uploadSwiftLargeObjectReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteSwiftLargeObjectStub        func(containerName string, objectFileName string) error
	deleteSwiftLargeObjectMutex       sync.RWMutex
	deleteSwiftLargeObjectArgsForCall []struct {
		containerName  string
		objectFileName string
	}
	deleteSwiftLargeObjectReturns struct {
		result1 error
	}
	deleteSwiftLargeObjectReturnsOnCall map[int]struct {
		result1 error
	}
	CreateImageFromExternalSourceStub        func(imageName string, note string, cluster string, osCode string) (int, error)
	createImageFromExternalSourceMutex       sync.RWMutex
	createImageFromExternalSourceArgsForCall []struct {
		imageName string
		note      string
		cluster   string
		osCode    string
	}
	createImageFromExternalSourceReturns struct {
		result1 int
		result2 error
	}
	createImageFromExternalSourceReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) CancelInstance(id int) error {
	fake.cancelInstanceMutex.Lock()
	ret, specificReturn := fake.cancelInstanceReturnsOnCall[len(fake.cancelInstanceArgsForCall)]
	fake.cancelInstanceArgsForCall = append(fake.cancelInstanceArgsForCall, struct {
		id int
	}{id})
	fake.recordInvocation("CancelInstance", []interface{}{id})
	fake.cancelInstanceMutex.Unlock()
	if fake.CancelInstanceStub != nil {
		return fake.CancelInstanceStub(id)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.cancelInstanceReturns.result1
}

func (fake *FakeClient) CancelInstanceCallCount() int {
	fake.cancelInstanceMutex.RLock()
	defer fake.cancelInstanceMutex.RUnlock()
	return len(fake.cancelInstanceArgsForCall)
}

func (fake *FakeClient) CancelInstanceArgsForCall(i int) int {
	fake.cancelInstanceMutex.RLock()
	defer fake.cancelInstanceMutex.RUnlock()
	return fake.cancelInstanceArgsForCall[i].id
}

func (fake *FakeClient) CancelInstanceReturns(result1 error) {
	fake.CancelInstanceStub = nil
	fake.cancelInstanceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) CancelInstanceReturnsOnCall(i int, result1 error) {
	fake.CancelInstanceStub = nil
	if fake.cancelInstanceReturnsOnCall == nil {
		fake.cancelInstanceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cancelInstanceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) CreateInstance(template *datatypes.Virtual_Guest) (*datatypes.Virtual_Guest, error) {
	fake.createInstanceMutex.Lock()
	ret, specificReturn := fake.createInstanceReturnsOnCall[len(fake.createInstanceArgsForCall)]
	fake.createInstanceArgsForCall = append(fake.createInstanceArgsForCall, struct {
		template *datatypes.Virtual_Guest
	}{template})
	fake.recordInvocation("CreateInstance", []interface{}{template})
	fake.createInstanceMutex.Unlock()
	if fake.CreateInstanceStub != nil {
		return fake.CreateInstanceStub(template)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createInstanceReturns.result1, fake.createInstanceReturns.result2
}

func (fake *FakeClient) CreateInstanceCallCount() int {
	fake.createInstanceMutex.RLock()
	defer fake.createInstanceMutex.RUnlock()
	return len(fake.createInstanceArgsForCall)
}

func (fake *FakeClient) CreateInstanceArgsForCall(i int) *datatypes.Virtual_Guest {
	fake.createInstanceMutex.RLock()
	defer fake.createInstanceMutex.RUnlock()
	return fake.createInstanceArgsForCall[i].template
}

func (fake *FakeClient) CreateInstanceReturns(result1 *datatypes.Virtual_Guest, result2 error) {
	fake.CreateInstanceStub = nil
	fake.createInstanceReturns = struct {
		result1 *datatypes.Virtual_Guest
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateInstanceReturnsOnCall(i int, result1 *datatypes.Virtual_Guest, result2 error) {
	fake.CreateInstanceStub = nil
	if fake.createInstanceReturnsOnCall == nil {
		fake.createInstanceReturnsOnCall = make(map[int]struct {
			result1 *datatypes.Virtual_Guest
			result2 error
		})
	}
	fake.createInstanceReturnsOnCall[i] = struct {
		result1 *datatypes.Virtual_Guest
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) EditInstance(id int, template *datatypes.Virtual_Guest) (bool, error) {
	fake.editInstanceMutex.Lock()
	ret, specificReturn := fake.editInstanceReturnsOnCall[len(fake.editInstanceArgsForCall)]
	fake.editInstanceArgsForCall = append(fake.editInstanceArgsForCall, struct {
		id       int
		template *datatypes.Virtual_Guest
	}{id, template})
	fake.recordInvocation("EditInstance", []interface{}{id, template})
	fake.editInstanceMutex.Unlock()
	if fake.EditInstanceStub != nil {
		return fake.EditInstanceStub(id, template)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.editInstanceReturns.result1, fake.editInstanceReturns.result2
}

func (fake *FakeClient) EditInstanceCallCount() int {
	fake.editInstanceMutex.RLock()
	defer fake.editInstanceMutex.RUnlock()
	return len(fake.editInstanceArgsForCall)
}

func (fake *FakeClient) EditInstanceArgsForCall(i int) (int, *datatypes.Virtual_Guest) {
	fake.editInstanceMutex.RLock()
	defer fake.editInstanceMutex.RUnlock()
	return fake.editInstanceArgsForCall[i].id, fake.editInstanceArgsForCall[i].template
}

func (fake *FakeClient) EditInstanceReturns(result1 bool, result2 error) {
	fake.EditInstanceStub = nil
	fake.editInstanceReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) EditInstanceReturnsOnCall(i int, result1 bool, result2 error) {
	fake.EditInstanceStub = nil
	if fake.editInstanceReturnsOnCall == nil {
		fake.editInstanceReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.editInstanceReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetInstance(id int, mask string) (*datatypes.Virtual_Guest, bool, error) {
	fake.getInstanceMutex.Lock()
	ret, specificReturn := fake.getInstanceReturnsOnCall[len(fake.getInstanceArgsForCall)]
	fake.getInstanceArgsForCall = append(fake.getInstanceArgsForCall, struct {
		id   int
		mask string
	}{id, mask})
	fake.recordInvocation("GetInstance", []interface{}{id, mask})
	fake.getInstanceMutex.Unlock()
	if fake.GetInstanceStub != nil {
		return fake.GetInstanceStub(id, mask)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.getInstanceReturns.result1, fake.getInstanceReturns.result2, fake.getInstanceReturns.result3
}

func (fake *FakeClient) GetInstanceCallCount() int {
	fake.getInstanceMutex.RLock()
	defer fake.getInstanceMutex.RUnlock()
	return len(fake.getInstanceArgsForCall)
}

func (fake *FakeClient) GetInstanceArgsForCall(i int) (int, string) {
	fake.getInstanceMutex.RLock()
	defer fake.getInstanceMutex.RUnlock()
	return fake.getInstanceArgsForCall[i].id, fake.getInstanceArgsForCall[i].mask
}

func (fake *FakeClient) GetInstanceReturns(result1 *datatypes.Virtual_Guest, result2 bool, result3 error) {
	fake.GetInstanceStub = nil
	fake.getInstanceReturns = struct {
		result1 *datatypes.Virtual_Guest
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetInstanceReturnsOnCall(i int, result1 *datatypes.Virtual_Guest, result2 bool, result3 error) {
	fake.GetInstanceStub = nil
	if fake.getInstanceReturnsOnCall == nil {
		fake.getInstanceReturnsOnCall = make(map[int]struct {
			result1 *datatypes.Virtual_Guest
			result2 bool
			result3 error
		})
	}
	fake.getInstanceReturnsOnCall[i] = struct {
		result1 *datatypes.Virtual_Guest
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetInstanceByPrimaryBackendIpAddress(ip string) (*datatypes.Virtual_Guest, bool, error) {
	fake.getInstanceByPrimaryBackendIpAddressMutex.Lock()
	ret, specificReturn := fake.getInstanceByPrimaryBackendIpAddressReturnsOnCall[len(fake.getInstanceByPrimaryBackendIpAddressArgsForCall)]
	fake.getInstanceByPrimaryBackendIpAddressArgsForCall = append(fake.getInstanceByPrimaryBackendIpAddressArgsForCall, struct {
		ip string
	}{ip})
	fake.recordInvocation("GetInstanceByPrimaryBackendIpAddress", []interface{}{ip})
	fake.getInstanceByPrimaryBackendIpAddressMutex.Unlock()
	if fake.GetInstanceByPrimaryBackendIpAddressStub != nil {
		return fake.GetInstanceByPrimaryBackendIpAddressStub(ip)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.getInstanceByPrimaryBackendIpAddressReturns.result1, fake.getInstanceByPrimaryBackendIpAddressReturns.result2, fake.getInstanceByPrimaryBackendIpAddressReturns.result3
}

func (fake *FakeClient) GetInstanceByPrimaryBackendIpAddressCallCount() int {
	fake.getInstanceByPrimaryBackendIpAddressMutex.RLock()
	defer fake.getInstanceByPrimaryBackendIpAddressMutex.RUnlock()
	return len(fake.getInstanceByPrimaryBackendIpAddressArgsForCall)
}

func (fake *FakeClient) GetInstanceByPrimaryBackendIpAddressArgsForCall(i int) string {
	fake.getInstanceByPrimaryBackendIpAddressMutex.RLock()
	defer fake.getInstanceByPrimaryBackendIpAddressMutex.RUnlock()
	return fake.getInstanceByPrimaryBackendIpAddressArgsForCall[i].ip
}

func (fake *FakeClient) GetInstanceByPrimaryBackendIpAddressReturns(result1 *datatypes.Virtual_Guest, result2 bool, result3 error) {
	fake.GetInstanceByPrimaryBackendIpAddressStub = nil
	fake.getInstanceByPrimaryBackendIpAddressReturns = struct {
		result1 *datatypes.Virtual_Guest
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetInstanceByPrimaryBackendIpAddressReturnsOnCall(i int, result1 *datatypes.Virtual_Guest, result2 bool, result3 error) {
	fake.GetInstanceByPrimaryBackendIpAddressStub = nil
	if fake.getInstanceByPrimaryBackendIpAddressReturnsOnCall == nil {
		fake.getInstanceByPrimaryBackendIpAddressReturnsOnCall = make(map[int]struct {
			result1 *datatypes.Virtual_Guest
			result2 bool
			result3 error
		})
	}
	fake.getInstanceByPrimaryBackendIpAddressReturnsOnCall[i] = struct {
		result1 *datatypes.Virtual_Guest
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetInstanceByPrimaryIpAddress(ip string) (*datatypes.Virtual_Guest, bool, error) {
	fake.getInstanceByPrimaryIpAddressMutex.Lock()
	ret, specificReturn := fake.getInstanceByPrimaryIpAddressReturnsOnCall[len(fake.getInstanceByPrimaryIpAddressArgsForCall)]
	fake.getInstanceByPrimaryIpAddressArgsForCall = append(fake.getInstanceByPrimaryIpAddressArgsForCall, struct {
		ip string
	}{ip})
	fake.recordInvocation("GetInstanceByPrimaryIpAddress", []interface{}{ip})
	fake.getInstanceByPrimaryIpAddressMutex.Unlock()
	if fake.GetInstanceByPrimaryIpAddressStub != nil {
		return fake.GetInstanceByPrimaryIpAddressStub(ip)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.getInstanceByPrimaryIpAddressReturns.result1, fake.getInstanceByPrimaryIpAddressReturns.result2, fake.getInstanceByPrimaryIpAddressReturns.result3
}

func (fake *FakeClient) GetInstanceByPrimaryIpAddressCallCount() int {
	fake.getInstanceByPrimaryIpAddressMutex.RLock()
	defer fake.getInstanceByPrimaryIpAddressMutex.RUnlock()
	return len(fake.getInstanceByPrimaryIpAddressArgsForCall)
}

func (fake *FakeClient) GetInstanceByPrimaryIpAddressArgsForCall(i int) string {
	fake.getInstanceByPrimaryIpAddressMutex.RLock()
	defer fake.getInstanceByPrimaryIpAddressMutex.RUnlock()
	return fake.getInstanceByPrimaryIpAddressArgsForCall[i].ip
}

func (fake *FakeClient) GetInstanceByPrimaryIpAddressReturns(result1 *datatypes.Virtual_Guest, result2 bool, result3 error) {
	fake.GetInstanceByPrimaryIpAddressStub = nil
	fake.getInstanceByPrimaryIpAddressReturns = struct {
		result1 *datatypes.Virtual_Guest
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetInstanceByPrimaryIpAddressReturnsOnCall(i int, result1 *datatypes.Virtual_Guest, result2 bool, result3 error) {
	fake.GetInstanceByPrimaryIpAddressStub = nil
	if fake.getInstanceByPrimaryIpAddressReturnsOnCall == nil {
		fake.getInstanceByPrimaryIpAddressReturnsOnCall = make(map[int]struct {
			result1 *datatypes.Virtual_Guest
			result2 bool
			result3 error
		})
	}
	fake.getInstanceByPrimaryIpAddressReturnsOnCall[i] = struct {
		result1 *datatypes.Virtual_Guest
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) RebootInstance(id int, soft bool, hard bool) error {
	fake.rebootInstanceMutex.Lock()
	ret, specificReturn := fake.rebootInstanceReturnsOnCall[len(fake.rebootInstanceArgsForCall)]
	fake.rebootInstanceArgsForCall = append(fake.rebootInstanceArgsForCall, struct {
		id   int
		soft bool
		hard bool
	}{id, soft, hard})
	fake.recordInvocation("RebootInstance", []interface{}{id, soft, hard})
	fake.rebootInstanceMutex.Unlock()
	if fake.RebootInstanceStub != nil {
		return fake.RebootInstanceStub(id, soft, hard)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.rebootInstanceReturns.result1
}

func (fake *FakeClient) RebootInstanceCallCount() int {
	fake.rebootInstanceMutex.RLock()
	defer fake.rebootInstanceMutex.RUnlock()
	return len(fake.rebootInstanceArgsForCall)
}

func (fake *FakeClient) RebootInstanceArgsForCall(i int) (int, bool, bool) {
	fake.rebootInstanceMutex.RLock()
	defer fake.rebootInstanceMutex.RUnlock()
	return fake.rebootInstanceArgsForCall[i].id, fake.rebootInstanceArgsForCall[i].soft, fake.rebootInstanceArgsForCall[i].hard
}

func (fake *FakeClient) RebootInstanceReturns(result1 error) {
	fake.RebootInstanceStub = nil
	fake.rebootInstanceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) RebootInstanceReturnsOnCall(i int, result1 error) {
	fake.RebootInstanceStub = nil
	if fake.rebootInstanceReturnsOnCall == nil {
		fake.rebootInstanceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.rebootInstanceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) ReloadInstance(id int, stemcellId int, sshKeyIds []int, hostname string, domain string) error {
	var sshKeyIdsCopy []int
	if sshKeyIds != nil {
		sshKeyIdsCopy = make([]int, len(sshKeyIds))
		copy(sshKeyIdsCopy, sshKeyIds)
	}
	fake.reloadInstanceMutex.Lock()
	ret, specificReturn := fake.reloadInstanceReturnsOnCall[len(fake.reloadInstanceArgsForCall)]
	fake.reloadInstanceArgsForCall = append(fake.reloadInstanceArgsForCall, struct {
		id         int
		stemcellId int
		sshKeyIds  []int
		hostname   string
		domain     string
	}{id, stemcellId, sshKeyIdsCopy, hostname, domain})
	fake.recordInvocation("ReloadInstance", []interface{}{id, stemcellId, sshKeyIdsCopy, hostname, domain})
	fake.reloadInstanceMutex.Unlock()
	if fake.ReloadInstanceStub != nil {
		return fake.ReloadInstanceStub(id, stemcellId, sshKeyIds, hostname, domain)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.reloadInstanceReturns.result1
}

func (fake *FakeClient) ReloadInstanceCallCount() int {
	fake.reloadInstanceMutex.RLock()
	defer fake.reloadInstanceMutex.RUnlock()
	return len(fake.reloadInstanceArgsForCall)
}

func (fake *FakeClient) ReloadInstanceArgsForCall(i int) (int, int, []int, string, string) {
	fake.reloadInstanceMutex.RLock()
	defer fake.reloadInstanceMutex.RUnlock()
	return fake.reloadInstanceArgsForCall[i].id, fake.reloadInstanceArgsForCall[i].stemcellId, fake.reloadInstanceArgsForCall[i].sshKeyIds, fake.reloadInstanceArgsForCall[i].hostname, fake.reloadInstanceArgsForCall[i].domain
}

func (fake *FakeClient) ReloadInstanceReturns(result1 error) {
	fake.ReloadInstanceStub = nil
	fake.reloadInstanceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) ReloadInstanceReturnsOnCall(i int, result1 error) {
	fake.ReloadInstanceStub = nil
	if fake.reloadInstanceReturnsOnCall == nil {
		fake.reloadInstanceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.reloadInstanceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) UpgradeInstanceConfig(id int, cpu int, memory int, network int, privateCPU bool) error {
	fake.upgradeInstanceConfigMutex.Lock()
	ret, specificReturn := fake.upgradeInstanceConfigReturnsOnCall[len(fake.upgradeInstanceConfigArgsForCall)]
	fake.upgradeInstanceConfigArgsForCall = append(fake.upgradeInstanceConfigArgsForCall, struct {
		id         int
		cpu        int
		memory     int
		network    int
		privateCPU bool
	}{id, cpu, memory, network, privateCPU})
	fake.recordInvocation("UpgradeInstanceConfig", []interface{}{id, cpu, memory, network, privateCPU})
	fake.upgradeInstanceConfigMutex.Unlock()
	if fake.UpgradeInstanceConfigStub != nil {
		return fake.UpgradeInstanceConfigStub(id, cpu, memory, network, privateCPU)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.upgradeInstanceConfigReturns.result1
}

func (fake *FakeClient) UpgradeInstanceConfigCallCount() int {
	fake.upgradeInstanceConfigMutex.RLock()
	defer fake.upgradeInstanceConfigMutex.RUnlock()
	return len(fake.upgradeInstanceConfigArgsForCall)
}

func (fake *FakeClient) UpgradeInstanceConfigArgsForCall(i int) (int, int, int, int, bool) {
	fake.upgradeInstanceConfigMutex.RLock()
	defer fake.upgradeInstanceConfigMutex.RUnlock()
	return fake.upgradeInstanceConfigArgsForCall[i].id, fake.upgradeInstanceConfigArgsForCall[i].cpu, fake.upgradeInstanceConfigArgsForCall[i].memory, fake.upgradeInstanceConfigArgsForCall[i].network, fake.upgradeInstanceConfigArgsForCall[i].privateCPU
}

func (fake *FakeClient) UpgradeInstanceConfigReturns(result1 error) {
	fake.UpgradeInstanceConfigStub = nil
	fake.upgradeInstanceConfigReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) UpgradeInstanceConfigReturnsOnCall(i int, result1 error) {
	fake.UpgradeInstanceConfigStub = nil
	if fake.upgradeInstanceConfigReturnsOnCall == nil {
		fake.upgradeInstanceConfigReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.upgradeInstanceConfigReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) UpgradeInstance(id int, cpu int, memory int, network int, privateCPU bool, secondDiskSize int) (int, error) {
	fake.upgradeInstanceMutex.Lock()
	ret, specificReturn := fake.upgradeInstanceReturnsOnCall[len(fake.upgradeInstanceArgsForCall)]
	fake.upgradeInstanceArgsForCall = append(fake.upgradeInstanceArgsForCall, struct {
		id             int
		cpu            int
		memory         int
		network        int
		privateCPU     bool
		secondDiskSize int
	}{id, cpu, memory, network, privateCPU, secondDiskSize})
	fake.recordInvocation("UpgradeInstance", []interface{}{id, cpu, memory, network, privateCPU, secondDiskSize})
	fake.upgradeInstanceMutex.Unlock()
	if fake.UpgradeInstanceStub != nil {
		return fake.UpgradeInstanceStub(id, cpu, memory, network, privateCPU, secondDiskSize)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.upgradeInstanceReturns.result1, fake.upgradeInstanceReturns.result2
}

func (fake *FakeClient) UpgradeInstanceCallCount() int {
	fake.upgradeInstanceMutex.RLock()
	defer fake.upgradeInstanceMutex.RUnlock()
	return len(fake.upgradeInstanceArgsForCall)
}

func (fake *FakeClient) UpgradeInstanceArgsForCall(i int) (int, int, int, int, bool, int) {
	fake.upgradeInstanceMutex.RLock()
	defer fake.upgradeInstanceMutex.RUnlock()
	return fake.upgradeInstanceArgsForCall[i].id, fake.upgradeInstanceArgsForCall[i].cpu, fake.upgradeInstanceArgsForCall[i].memory, fake.upgradeInstanceArgsForCall[i].network, fake.upgradeInstanceArgsForCall[i].privateCPU, fake.upgradeInstanceArgsForCall[i].secondDiskSize
}

func (fake *FakeClient) UpgradeInstanceReturns(result1 int, result2 error) {
	fake.UpgradeInstanceStub = nil
	fake.upgradeInstanceReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpgradeInstanceReturnsOnCall(i int, result1 int, result2 error) {
	fake.UpgradeInstanceStub = nil
	if fake.upgradeInstanceReturnsOnCall == nil {
		fake.upgradeInstanceReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.upgradeInstanceReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) WaitInstanceUntilReady(id int, until time.Time) error {
	fake.waitInstanceUntilReadyMutex.Lock()
	ret, specificReturn := fake.waitInstanceUntilReadyReturnsOnCall[len(fake.waitInstanceUntilReadyArgsForCall)]
	fake.waitInstanceUntilReadyArgsForCall = append(fake.waitInstanceUntilReadyArgsForCall, struct {
		id    int
		until time.Time
	}{id, until})
	fake.recordInvocation("WaitInstanceUntilReady", []interface{}{id, until})
	fake.waitInstanceUntilReadyMutex.Unlock()
	if fake.WaitInstanceUntilReadyStub != nil {
		return fake.WaitInstanceUntilReadyStub(id, until)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.waitInstanceUntilReadyReturns.result1
}

func (fake *FakeClient) WaitInstanceUntilReadyCallCount() int {
	fake.waitInstanceUntilReadyMutex.RLock()
	defer fake.waitInstanceUntilReadyMutex.RUnlock()
	return len(fake.waitInstanceUntilReadyArgsForCall)
}

func (fake *FakeClient) WaitInstanceUntilReadyArgsForCall(i int) (int, time.Time) {
	fake.waitInstanceUntilReadyMutex.RLock()
	defer fake.waitInstanceUntilReadyMutex.RUnlock()
	return fake.waitInstanceUntilReadyArgsForCall[i].id, fake.waitInstanceUntilReadyArgsForCall[i].until
}

func (fake *FakeClient) WaitInstanceUntilReadyReturns(result1 error) {
	fake.WaitInstanceUntilReadyStub = nil
	fake.waitInstanceUntilReadyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WaitInstanceUntilReadyReturnsOnCall(i int, result1 error) {
	fake.WaitInstanceUntilReadyStub = nil
	if fake.waitInstanceUntilReadyReturnsOnCall == nil {
		fake.waitInstanceUntilReadyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.waitInstanceUntilReadyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WaitInstanceUntilReadyWithTicket(id int, until time.Time) error {
	fake.waitInstanceUntilReadyWithTicketMutex.Lock()
	ret, specificReturn := fake.waitInstanceUntilReadyWithTicketReturnsOnCall[len(fake.waitInstanceUntilReadyWithTicketArgsForCall)]
	fake.waitInstanceUntilReadyWithTicketArgsForCall = append(fake.waitInstanceUntilReadyWithTicketArgsForCall, struct {
		id    int
		until time.Time
	}{id, until})
	fake.recordInvocation("WaitInstanceUntilReadyWithTicket", []interface{}{id, until})
	fake.waitInstanceUntilReadyWithTicketMutex.Unlock()
	if fake.WaitInstanceUntilReadyWithTicketStub != nil {
		return fake.WaitInstanceUntilReadyWithTicketStub(id, until)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.waitInstanceUntilReadyWithTicketReturns.result1
}

func (fake *FakeClient) WaitInstanceUntilReadyWithTicketCallCount() int {
	fake.waitInstanceUntilReadyWithTicketMutex.RLock()
	defer fake.waitInstanceUntilReadyWithTicketMutex.RUnlock()
	return len(fake.waitInstanceUntilReadyWithTicketArgsForCall)
}

func (fake *FakeClient) WaitInstanceUntilReadyWithTicketArgsForCall(i int) (int, time.Time) {
	fake.waitInstanceUntilReadyWithTicketMutex.RLock()
	defer fake.waitInstanceUntilReadyWithTicketMutex.RUnlock()
	return fake.waitInstanceUntilReadyWithTicketArgsForCall[i].id, fake.waitInstanceUntilReadyWithTicketArgsForCall[i].until
}

func (fake *FakeClient) WaitInstanceUntilReadyWithTicketReturns(result1 error) {
	fake.WaitInstanceUntilReadyWithTicketStub = nil
	fake.waitInstanceUntilReadyWithTicketReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WaitInstanceUntilReadyWithTicketReturnsOnCall(i int, result1 error) {
	fake.WaitInstanceUntilReadyWithTicketStub = nil
	if fake.waitInstanceUntilReadyWithTicketReturnsOnCall == nil {
		fake.waitInstanceUntilReadyWithTicketReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.waitInstanceUntilReadyWithTicketReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WaitInstanceHasActiveTransaction(id int, until time.Time) error {
	fake.waitInstanceHasActiveTransactionMutex.Lock()
	ret, specificReturn := fake.waitInstanceHasActiveTransactionReturnsOnCall[len(fake.waitInstanceHasActiveTransactionArgsForCall)]
	fake.waitInstanceHasActiveTransactionArgsForCall = append(fake.waitInstanceHasActiveTransactionArgsForCall, struct {
		id    int
		until time.Time
	}{id, until})
	fake.recordInvocation("WaitInstanceHasActiveTransaction", []interface{}{id, until})
	fake.waitInstanceHasActiveTransactionMutex.Unlock()
	if fake.WaitInstanceHasActiveTransactionStub != nil {
		return fake.WaitInstanceHasActiveTransactionStub(id, until)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.waitInstanceHasActiveTransactionReturns.result1
}

func (fake *FakeClient) WaitInstanceHasActiveTransactionCallCount() int {
	fake.waitInstanceHasActiveTransactionMutex.RLock()
	defer fake.waitInstanceHasActiveTransactionMutex.RUnlock()
	return len(fake.waitInstanceHasActiveTransactionArgsForCall)
}

func (fake *FakeClient) WaitInstanceHasActiveTransactionArgsForCall(i int) (int, time.Time) {
	fake.waitInstanceHasActiveTransactionMutex.RLock()
	defer fake.waitInstanceHasActiveTransactionMutex.RUnlock()
	return fake.waitInstanceHasActiveTransactionArgsForCall[i].id, fake.waitInstanceHasActiveTransactionArgsForCall[i].until
}

func (fake *FakeClient) WaitInstanceHasActiveTransactionReturns(result1 error) {
	fake.WaitInstanceHasActiveTransactionStub = nil
	fake.waitInstanceHasActiveTransactionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WaitInstanceHasActiveTransactionReturnsOnCall(i int, result1 error) {
	fake.WaitInstanceHasActiveTransactionStub = nil
	if fake.waitInstanceHasActiveTransactionReturnsOnCall == nil {
		fake.waitInstanceHasActiveTransactionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.waitInstanceHasActiveTransactionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WaitInstanceHasNoneActiveTransaction(id int, until time.Time) error {
	fake.waitInstanceHasNoneActiveTransactionMutex.Lock()
	ret, specificReturn := fake.waitInstanceHasNoneActiveTransactionReturnsOnCall[len(fake.waitInstanceHasNoneActiveTransactionArgsForCall)]
	fake.waitInstanceHasNoneActiveTransactionArgsForCall = append(fake.waitInstanceHasNoneActiveTransactionArgsForCall, struct {
		id    int
		until time.Time
	}{id, until})
	fake.recordInvocation("WaitInstanceHasNoneActiveTransaction", []interface{}{id, until})
	fake.waitInstanceHasNoneActiveTransactionMutex.Unlock()
	if fake.WaitInstanceHasNoneActiveTransactionStub != nil {
		return fake.WaitInstanceHasNoneActiveTransactionStub(id, until)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.waitInstanceHasNoneActiveTransactionReturns.result1
}

func (fake *FakeClient) WaitInstanceHasNoneActiveTransactionCallCount() int {
	fake.waitInstanceHasNoneActiveTransactionMutex.RLock()
	defer fake.waitInstanceHasNoneActiveTransactionMutex.RUnlock()
	return len(fake.waitInstanceHasNoneActiveTransactionArgsForCall)
}

func (fake *FakeClient) WaitInstanceHasNoneActiveTransactionArgsForCall(i int) (int, time.Time) {
	fake.waitInstanceHasNoneActiveTransactionMutex.RLock()
	defer fake.waitInstanceHasNoneActiveTransactionMutex.RUnlock()
	return fake.waitInstanceHasNoneActiveTransactionArgsForCall[i].id, fake.waitInstanceHasNoneActiveTransactionArgsForCall[i].until
}

func (fake *FakeClient) WaitInstanceHasNoneActiveTransactionReturns(result1 error) {
	fake.WaitInstanceHasNoneActiveTransactionStub = nil
	fake.waitInstanceHasNoneActiveTransactionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WaitInstanceHasNoneActiveTransactionReturnsOnCall(i int, result1 error) {
	fake.WaitInstanceHasNoneActiveTransactionStub = nil
	if fake.waitInstanceHasNoneActiveTransactionReturnsOnCall == nil {
		fake.waitInstanceHasNoneActiveTransactionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.waitInstanceHasNoneActiveTransactionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WaitVolumeProvisioningWithOrderId(orderId int, until time.Time) (*datatypes.Network_Storage, error) {
	fake.waitVolumeProvisioningWithOrderIdMutex.Lock()
	ret, specificReturn := fake.waitVolumeProvisioningWithOrderIdReturnsOnCall[len(fake.waitVolumeProvisioningWithOrderIdArgsForCall)]
	fake.waitVolumeProvisioningWithOrderIdArgsForCall = append(fake.waitVolumeProvisioningWithOrderIdArgsForCall, struct {
		orderId int
		until   time.Time
	}{orderId, until})
	fake.recordInvocation("WaitVolumeProvisioningWithOrderId", []interface{}{orderId, until})
	fake.waitVolumeProvisioningWithOrderIdMutex.Unlock()
	if fake.WaitVolumeProvisioningWithOrderIdStub != nil {
		return fake.WaitVolumeProvisioningWithOrderIdStub(orderId, until)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.waitVolumeProvisioningWithOrderIdReturns.result1, fake.waitVolumeProvisioningWithOrderIdReturns.result2
}

func (fake *FakeClient) WaitVolumeProvisioningWithOrderIdCallCount() int {
	fake.waitVolumeProvisioningWithOrderIdMutex.RLock()
	defer fake.waitVolumeProvisioningWithOrderIdMutex.RUnlock()
	return len(fake.waitVolumeProvisioningWithOrderIdArgsForCall)
}

func (fake *FakeClient) WaitVolumeProvisioningWithOrderIdArgsForCall(i int) (int, time.Time) {
	fake.waitVolumeProvisioningWithOrderIdMutex.RLock()
	defer fake.waitVolumeProvisioningWithOrderIdMutex.RUnlock()
	return fake.waitVolumeProvisioningWithOrderIdArgsForCall[i].orderId, fake.waitVolumeProvisioningWithOrderIdArgsForCall[i].until
}

func (fake *FakeClient) WaitVolumeProvisioningWithOrderIdReturns(result1 *datatypes.Network_Storage, result2 error) {
	fake.WaitVolumeProvisioningWithOrderIdStub = nil
	fake.waitVolumeProvisioningWithOrderIdReturns = struct {
		result1 *datatypes.Network_Storage
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) WaitVolumeProvisioningWithOrderIdReturnsOnCall(i int, result1 *datatypes.Network_Storage, result2 error) {
	fake.WaitVolumeProvisioningWithOrderIdStub = nil
	if fake.waitVolumeProvisioningWithOrderIdReturnsOnCall == nil {
		fake.waitVolumeProvisioningWithOrderIdReturnsOnCall = make(map[int]struct {
			result1 *datatypes.Network_Storage
			result2 error
		})
	}
	fake.waitVolumeProvisioningWithOrderIdReturnsOnCall[i] = struct {
		result1 *datatypes.Network_Storage
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SetTags(id int, tags string) (bool, error) {
	fake.setTagsMutex.Lock()
	ret, specificReturn := fake.setTagsReturnsOnCall[len(fake.setTagsArgsForCall)]
	fake.setTagsArgsForCall = append(fake.setTagsArgsForCall, struct {
		id   int
		tags string
	}{id, tags})
	fake.recordInvocation("SetTags", []interface{}{id, tags})
	fake.setTagsMutex.Unlock()
	if fake.SetTagsStub != nil {
		return fake.SetTagsStub(id, tags)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.setTagsReturns.result1, fake.setTagsReturns.result2
}

func (fake *FakeClient) SetTagsCallCount() int {
	fake.setTagsMutex.RLock()
	defer fake.setTagsMutex.RUnlock()
	return len(fake.setTagsArgsForCall)
}

func (fake *FakeClient) SetTagsArgsForCall(i int) (int, string) {
	fake.setTagsMutex.RLock()
	defer fake.setTagsMutex.RUnlock()
	return fake.setTagsArgsForCall[i].id, fake.setTagsArgsForCall[i].tags
}

func (fake *FakeClient) SetTagsReturns(result1 bool, result2 error) {
	fake.SetTagsStub = nil
	fake.setTagsReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SetTagsReturnsOnCall(i int, result1 bool, result2 error) {
	fake.SetTagsStub = nil
	if fake.setTagsReturnsOnCall == nil {
		fake.setTagsReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.setTagsReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SetInstanceMetadata(id int, userData *string) (bool, error) {
	fake.setInstanceMetadataMutex.Lock()
	ret, specificReturn := fake.setInstanceMetadataReturnsOnCall[len(fake.setInstanceMetadataArgsForCall)]
	fake.setInstanceMetadataArgsForCall = append(fake.setInstanceMetadataArgsForCall, struct {
		id       int
		userData *string
	}{id, userData})
	fake.recordInvocation("SetInstanceMetadata", []interface{}{id, userData})
	fake.setInstanceMetadataMutex.Unlock()
	if fake.SetInstanceMetadataStub != nil {
		return fake.SetInstanceMetadataStub(id, userData)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.setInstanceMetadataReturns.result1, fake.setInstanceMetadataReturns.result2
}

func (fake *FakeClient) SetInstanceMetadataCallCount() int {
	fake.setInstanceMetadataMutex.RLock()
	defer fake.setInstanceMetadataMutex.RUnlock()
	return len(fake.setInstanceMetadataArgsForCall)
}

func (fake *FakeClient) SetInstanceMetadataArgsForCall(i int) (int, *string) {
	fake.setInstanceMetadataMutex.RLock()
	defer fake.setInstanceMetadataMutex.RUnlock()
	return fake.setInstanceMetadataArgsForCall[i].id, fake.setInstanceMetadataArgsForCall[i].userData
}

func (fake *FakeClient) SetInstanceMetadataReturns(result1 bool, result2 error) {
	fake.SetInstanceMetadataStub = nil
	fake.setInstanceMetadataReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SetInstanceMetadataReturnsOnCall(i int, result1 bool, result2 error) {
	fake.SetInstanceMetadataStub = nil
	if fake.setInstanceMetadataReturnsOnCall == nil {
		fake.setInstanceMetadataReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.setInstanceMetadataReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) AttachSecondDiskToInstance(id int, diskSize int) error {
	fake.attachSecondDiskToInstanceMutex.Lock()
	ret, specificReturn := fake.attachSecondDiskToInstanceReturnsOnCall[len(fake.attachSecondDiskToInstanceArgsForCall)]
	fake.attachSecondDiskToInstanceArgsForCall = append(fake.attachSecondDiskToInstanceArgsForCall, struct {
		id       int
		diskSize int
	}{id, diskSize})
	fake.recordInvocation("AttachSecondDiskToInstance", []interface{}{id, diskSize})
	fake.attachSecondDiskToInstanceMutex.Unlock()
	if fake.AttachSecondDiskToInstanceStub != nil {
		return fake.AttachSecondDiskToInstanceStub(id, diskSize)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.attachSecondDiskToInstanceReturns.result1
}

func (fake *FakeClient) AttachSecondDiskToInstanceCallCount() int {
	fake.attachSecondDiskToInstanceMutex.RLock()
	defer fake.attachSecondDiskToInstanceMutex.RUnlock()
	return len(fake.attachSecondDiskToInstanceArgsForCall)
}

func (fake *FakeClient) AttachSecondDiskToInstanceArgsForCall(i int) (int, int) {
	fake.attachSecondDiskToInstanceMutex.RLock()
	defer fake.attachSecondDiskToInstanceMutex.RUnlock()
	return fake.attachSecondDiskToInstanceArgsForCall[i].id, fake.attachSecondDiskToInstanceArgsForCall[i].diskSize
}

func (fake *FakeClient) AttachSecondDiskToInstanceReturns(result1 error) {
	fake.AttachSecondDiskToInstanceStub = nil
	fake.attachSecondDiskToInstanceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) AttachSecondDiskToInstanceReturnsOnCall(i int, result1 error) {
	fake.AttachSecondDiskToInstanceStub = nil
	if fake.attachSecondDiskToInstanceReturnsOnCall == nil {
		fake.attachSecondDiskToInstanceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.attachSecondDiskToInstanceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) GetInstanceAllowedHost(id int) (*datatypes.Network_Storage_Allowed_Host, bool, error) {
	fake.getInstanceAllowedHostMutex.Lock()
	ret, specificReturn := fake.getInstanceAllowedHostReturnsOnCall[len(fake.getInstanceAllowedHostArgsForCall)]
	fake.getInstanceAllowedHostArgsForCall = append(fake.getInstanceAllowedHostArgsForCall, struct {
		id int
	}{id})
	fake.recordInvocation("GetInstanceAllowedHost", []interface{}{id})
	fake.getInstanceAllowedHostMutex.Unlock()
	if fake.GetInstanceAllowedHostStub != nil {
		return fake.GetInstanceAllowedHostStub(id)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.getInstanceAllowedHostReturns.result1, fake.getInstanceAllowedHostReturns.result2, fake.getInstanceAllowedHostReturns.result3
}

func (fake *FakeClient) GetInstanceAllowedHostCallCount() int {
	fake.getInstanceAllowedHostMutex.RLock()
	defer fake.getInstanceAllowedHostMutex.RUnlock()
	return len(fake.getInstanceAllowedHostArgsForCall)
}

func (fake *FakeClient) GetInstanceAllowedHostArgsForCall(i int) int {
	fake.getInstanceAllowedHostMutex.RLock()
	defer fake.getInstanceAllowedHostMutex.RUnlock()
	return fake.getInstanceAllowedHostArgsForCall[i].id
}

func (fake *FakeClient) GetInstanceAllowedHostReturns(result1 *datatypes.Network_Storage_Allowed_Host, result2 bool, result3 error) {
	fake.GetInstanceAllowedHostStub = nil
	fake.getInstanceAllowedHostReturns = struct {
		result1 *datatypes.Network_Storage_Allowed_Host
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetInstanceAllowedHostReturnsOnCall(i int, result1 *datatypes.Network_Storage_Allowed_Host, result2 bool, result3 error) {
	fake.GetInstanceAllowedHostStub = nil
	if fake.getInstanceAllowedHostReturnsOnCall == nil {
		fake.getInstanceAllowedHostReturnsOnCall = make(map[int]struct {
			result1 *datatypes.Network_Storage_Allowed_Host
			result2 bool
			result3 error
		})
	}
	fake.getInstanceAllowedHostReturnsOnCall[i] = struct {
		result1 *datatypes.Network_Storage_Allowed_Host
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) AuthorizeHostToVolume(instance *datatypes.Virtual_Guest, volumeId int, until time.Time) (bool, error) {
	fake.authorizeHostToVolumeMutex.Lock()
	ret, specificReturn := fake.authorizeHostToVolumeReturnsOnCall[len(fake.authorizeHostToVolumeArgsForCall)]
	fake.authorizeHostToVolumeArgsForCall = append(fake.authorizeHostToVolumeArgsForCall, struct {
		instance *datatypes.Virtual_Guest
		volumeId int
		until    time.Time
	}{instance, volumeId, until})
	fake.recordInvocation("AuthorizeHostToVolume", []interface{}{instance, volumeId, until})
	fake.authorizeHostToVolumeMutex.Unlock()
	if fake.AuthorizeHostToVolumeStub != nil {
		return fake.AuthorizeHostToVolumeStub(instance, volumeId, until)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.authorizeHostToVolumeReturns.result1, fake.authorizeHostToVolumeReturns.result2
}

func (fake *FakeClient) AuthorizeHostToVolumeCallCount() int {
	fake.authorizeHostToVolumeMutex.RLock()
	defer fake.authorizeHostToVolumeMutex.RUnlock()
	return len(fake.authorizeHostToVolumeArgsForCall)
}

func (fake *FakeClient) AuthorizeHostToVolumeArgsForCall(i int) (*datatypes.Virtual_Guest, int, time.Time) {
	fake.authorizeHostToVolumeMutex.RLock()
	defer fake.authorizeHostToVolumeMutex.RUnlock()
	return fake.authorizeHostToVolumeArgsForCall[i].instance, fake.authorizeHostToVolumeArgsForCall[i].volumeId, fake.authorizeHostToVolumeArgsForCall[i].until
}

func (fake *FakeClient) AuthorizeHostToVolumeReturns(result1 bool, result2 error) {
	fake.AuthorizeHostToVolumeStub = nil
	fake.authorizeHostToVolumeReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) AuthorizeHostToVolumeReturnsOnCall(i int, result1 bool, result2 error) {
	fake.AuthorizeHostToVolumeStub = nil
	if fake.authorizeHostToVolumeReturnsOnCall == nil {
		fake.authorizeHostToVolumeReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.authorizeHostToVolumeReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DeauthorizeHostToVolume(instance *datatypes.Virtual_Guest, volumeId int, until time.Time) (bool, error) {
	fake.deauthorizeHostToVolumeMutex.Lock()
	ret, specificReturn := fake.deauthorizeHostToVolumeReturnsOnCall[len(fake.deauthorizeHostToVolumeArgsForCall)]
	fake.deauthorizeHostToVolumeArgsForCall = append(fake.deauthorizeHostToVolumeArgsForCall, struct {
		instance *datatypes.Virtual_Guest
		volumeId int
		until    time.Time
	}{instance, volumeId, until})
	fake.recordInvocation("DeauthorizeHostToVolume", []interface{}{instance, volumeId, until})
	fake.deauthorizeHostToVolumeMutex.Unlock()
	if fake.DeauthorizeHostToVolumeStub != nil {
		return fake.DeauthorizeHostToVolumeStub(instance, volumeId, until)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.deauthorizeHostToVolumeReturns.result1, fake.deauthorizeHostToVolumeReturns.result2
}

func (fake *FakeClient) DeauthorizeHostToVolumeCallCount() int {
	fake.deauthorizeHostToVolumeMutex.RLock()
	defer fake.deauthorizeHostToVolumeMutex.RUnlock()
	return len(fake.deauthorizeHostToVolumeArgsForCall)
}

func (fake *FakeClient) DeauthorizeHostToVolumeArgsForCall(i int) (*datatypes.Virtual_Guest, int, time.Time) {
	fake.deauthorizeHostToVolumeMutex.RLock()
	defer fake.deauthorizeHostToVolumeMutex.RUnlock()
	return fake.deauthorizeHostToVolumeArgsForCall[i].instance, fake.deauthorizeHostToVolumeArgsForCall[i].volumeId, fake.deauthorizeHostToVolumeArgsForCall[i].until
}

func (fake *FakeClient) DeauthorizeHostToVolumeReturns(result1 bool, result2 error) {
	fake.DeauthorizeHostToVolumeStub = nil
	fake.deauthorizeHostToVolumeReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DeauthorizeHostToVolumeReturnsOnCall(i int, result1 bool, result2 error) {
	fake.DeauthorizeHostToVolumeStub = nil
	if fake.deauthorizeHostToVolumeReturnsOnCall == nil {
		fake.deauthorizeHostToVolumeReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.deauthorizeHostToVolumeReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateVolume(location string, size int, iops int, snapshotSpace int) (*datatypes.Network_Storage, error) {
	fake.createVolumeMutex.Lock()
	ret, specificReturn := fake.createVolumeReturnsOnCall[len(fake.createVolumeArgsForCall)]
	fake.createVolumeArgsForCall = append(fake.createVolumeArgsForCall, struct {
		location      string
		size          int
		iops          int
		snapshotSpace int
	}{location, size, iops, snapshotSpace})
	fake.recordInvocation("CreateVolume", []interface{}{location, size, iops, snapshotSpace})
	fake.createVolumeMutex.Unlock()
	if fake.CreateVolumeStub != nil {
		return fake.CreateVolumeStub(location, size, iops, snapshotSpace)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createVolumeReturns.result1, fake.createVolumeReturns.result2
}

func (fake *FakeClient) CreateVolumeCallCount() int {
	fake.createVolumeMutex.RLock()
	defer fake.createVolumeMutex.RUnlock()
	return len(fake.createVolumeArgsForCall)
}

func (fake *FakeClient) CreateVolumeArgsForCall(i int) (string, int, int, int) {
	fake.createVolumeMutex.RLock()
	defer fake.createVolumeMutex.RUnlock()
	return fake.createVolumeArgsForCall[i].location, fake.createVolumeArgsForCall[i].size, fake.createVolumeArgsForCall[i].iops, fake.createVolumeArgsForCall[i].snapshotSpace
}

func (fake *FakeClient) CreateVolumeReturns(result1 *datatypes.Network_Storage, result2 error) {
	fake.CreateVolumeStub = nil
	fake.createVolumeReturns = struct {
		result1 *datatypes.Network_Storage
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateVolumeReturnsOnCall(i int, result1 *datatypes.Network_Storage, result2 error) {
	fake.CreateVolumeStub = nil
	if fake.createVolumeReturnsOnCall == nil {
		fake.createVolumeReturnsOnCall = make(map[int]struct {
			result1 *datatypes.Network_Storage
			result2 error
		})
	}
	fake.createVolumeReturnsOnCall[i] = struct {
		result1 *datatypes.Network_Storage
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) OrderBlockVolume(storageType string, location string, size int, iops int) (*datatypes.Container_Product_Order_Receipt, error) {
	fake.orderBlockVolumeMutex.Lock()
	ret, specificReturn := fake.orderBlockVolumeReturnsOnCall[len(fake.orderBlockVolumeArgsForCall)]
	fake.orderBlockVolumeArgsForCall = append(fake.orderBlockVolumeArgsForCall, struct {
		storageType string
		location    string
		size        int
		iops        int
	}{storageType, location, size, iops})
	fake.recordInvocation("OrderBlockVolume", []interface{}{storageType, location, size, iops})
	fake.orderBlockVolumeMutex.Unlock()
	if fake.OrderBlockVolumeStub != nil {
		return fake.OrderBlockVolumeStub(storageType, location, size, iops)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.orderBlockVolumeReturns.result1, fake.orderBlockVolumeReturns.result2
}

func (fake *FakeClient) OrderBlockVolumeCallCount() int {
	fake.orderBlockVolumeMutex.RLock()
	defer fake.orderBlockVolumeMutex.RUnlock()
	return len(fake.orderBlockVolumeArgsForCall)
}

func (fake *FakeClient) OrderBlockVolumeArgsForCall(i int) (string, string, int, int) {
	fake.orderBlockVolumeMutex.RLock()
	defer fake.orderBlockVolumeMutex.RUnlock()
	return fake.orderBlockVolumeArgsForCall[i].storageType, fake.orderBlockVolumeArgsForCall[i].location, fake.orderBlockVolumeArgsForCall[i].size, fake.orderBlockVolumeArgsForCall[i].iops
}

func (fake *FakeClient) OrderBlockVolumeReturns(result1 *datatypes.Container_Product_Order_Receipt, result2 error) {
	fake.OrderBlockVolumeStub = nil
	fake.orderBlockVolumeReturns = struct {
		result1 *datatypes.Container_Product_Order_Receipt
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) OrderBlockVolumeReturnsOnCall(i int, result1 *datatypes.Container_Product_Order_Receipt, result2 error) {
	fake.OrderBlockVolumeStub = nil
	if fake.orderBlockVolumeReturnsOnCall == nil {
		fake.orderBlockVolumeReturnsOnCall = make(map[int]struct {
			result1 *datatypes.Container_Product_Order_Receipt
			result2 error
		})
	}
	fake.orderBlockVolumeReturnsOnCall[i] = struct {
		result1 *datatypes.Container_Product_Order_Receipt
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) OrderBlockVolume2(storageType string, location string, size int, iops int, snapshotSpace int) (*datatypes.Container_Product_Order_Receipt, error) {
	fake.orderBlockVolume2Mutex.Lock()
	ret, specificReturn := fake.orderBlockVolume2ReturnsOnCall[len(fake.orderBlockVolume2ArgsForCall)]
	fake.orderBlockVolume2ArgsForCall = append(fake.orderBlockVolume2ArgsForCall, struct {
		storageType   string
		location      string
		size          int
		iops          int
		snapshotSpace int
	}{storageType, location, size, iops, snapshotSpace})
	fake.recordInvocation("OrderBlockVolume2", []interface{}{storageType, location, size, iops, snapshotSpace})
	fake.orderBlockVolume2Mutex.Unlock()
	if fake.OrderBlockVolume2Stub != nil {
		return fake.OrderBlockVolume2Stub(storageType, location, size, iops, snapshotSpace)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.orderBlockVolume2Returns.result1, fake.orderBlockVolume2Returns.result2
}

func (fake *FakeClient) OrderBlockVolume2CallCount() int {
	fake.orderBlockVolume2Mutex.RLock()
	defer fake.orderBlockVolume2Mutex.RUnlock()
	return len(fake.orderBlockVolume2ArgsForCall)
}

func (fake *FakeClient) OrderBlockVolume2ArgsForCall(i int) (string, string, int, int, int) {
	fake.orderBlockVolume2Mutex.RLock()
	defer fake.orderBlockVolume2Mutex.RUnlock()
	return fake.orderBlockVolume2ArgsForCall[i].storageType, fake.orderBlockVolume2ArgsForCall[i].location, fake.orderBlockVolume2ArgsForCall[i].size, fake.orderBlockVolume2ArgsForCall[i].iops, fake.orderBlockVolume2ArgsForCall[i].snapshotSpace
}

func (fake *FakeClient) OrderBlockVolume2Returns(result1 *datatypes.Container_Product_Order_Receipt, result2 error) {
	fake.OrderBlockVolume2Stub = nil
	fake.orderBlockVolume2Returns = struct {
		result1 *datatypes.Container_Product_Order_Receipt
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) OrderBlockVolume2ReturnsOnCall(i int, result1 *datatypes.Container_Product_Order_Receipt, result2 error) {
	fake.OrderBlockVolume2Stub = nil
	if fake.orderBlockVolume2ReturnsOnCall == nil {
		fake.orderBlockVolume2ReturnsOnCall = make(map[int]struct {
			result1 *datatypes.Container_Product_Order_Receipt
			result2 error
		})
	}
	fake.orderBlockVolume2ReturnsOnCall[i] = struct {
		result1 *datatypes.Container_Product_Order_Receipt
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CancelBlockVolume(volumeId int, reason string, immediate bool) (bool, error) {
	fake.cancelBlockVolumeMutex.Lock()
	ret, specificReturn := fake.cancelBlockVolumeReturnsOnCall[len(fake.cancelBlockVolumeArgsForCall)]
	fake.cancelBlockVolumeArgsForCall = append(fake.cancelBlockVolumeArgsForCall, struct {
		volumeId  int
		reason    string
		immediate bool
	}{volumeId, reason, immediate})
	fake.recordInvocation("CancelBlockVolume", []interface{}{volumeId, reason, immediate})
	fake.cancelBlockVolumeMutex.Unlock()
	if fake.CancelBlockVolumeStub != nil {
		return fake.CancelBlockVolumeStub(volumeId, reason, immediate)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.cancelBlockVolumeReturns.result1, fake.cancelBlockVolumeReturns.result2
}

func (fake *FakeClient) CancelBlockVolumeCallCount() int {
	fake.cancelBlockVolumeMutex.RLock()
	defer fake.cancelBlockVolumeMutex.RUnlock()
	return len(fake.cancelBlockVolumeArgsForCall)
}

func (fake *FakeClient) CancelBlockVolumeArgsForCall(i int) (int, string, bool) {
	fake.cancelBlockVolumeMutex.RLock()
	defer fake.cancelBlockVolumeMutex.RUnlock()
	return fake.cancelBlockVolumeArgsForCall[i].volumeId, fake.cancelBlockVolumeArgsForCall[i].reason, fake.cancelBlockVolumeArgsForCall[i].immediate
}

func (fake *FakeClient) CancelBlockVolumeReturns(result1 bool, result2 error) {
	fake.CancelBlockVolumeStub = nil
	fake.cancelBlockVolumeReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CancelBlockVolumeReturnsOnCall(i int, result1 bool, result2 error) {
	fake.CancelBlockVolumeStub = nil
	if fake.cancelBlockVolumeReturnsOnCall == nil {
		fake.cancelBlockVolumeReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.cancelBlockVolumeReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetBlockVolumeDetails(volumeId int, mask string) (*datatypes.Network_Storage, bool, error) {
	fake.getBlockVolumeDetailsMutex.Lock()
	ret, specificReturn := fake.getBlockVolumeDetailsReturnsOnCall[len(fake.getBlockVolumeDetailsArgsForCall)]
	fake.getBlockVolumeDetailsArgsForCall = append(fake.getBlockVolumeDetailsArgsForCall, struct {
		volumeId int
		mask     string
	}{volumeId, mask})
	fake.recordInvocation("GetBlockVolumeDetails", []interface{}{volumeId, mask})
	fake.getBlockVolumeDetailsMutex.Unlock()
	if fake.GetBlockVolumeDetailsStub != nil {
		return fake.GetBlockVolumeDetailsStub(volumeId, mask)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.getBlockVolumeDetailsReturns.result1, fake.getBlockVolumeDetailsReturns.result2, fake.getBlockVolumeDetailsReturns.result3
}

func (fake *FakeClient) GetBlockVolumeDetailsCallCount() int {
	fake.getBlockVolumeDetailsMutex.RLock()
	defer fake.getBlockVolumeDetailsMutex.RUnlock()
	return len(fake.getBlockVolumeDetailsArgsForCall)
}

func (fake *FakeClient) GetBlockVolumeDetailsArgsForCall(i int) (int, string) {
	fake.getBlockVolumeDetailsMutex.RLock()
	defer fake.getBlockVolumeDetailsMutex.RUnlock()
	return fake.getBlockVolumeDetailsArgsForCall[i].volumeId, fake.getBlockVolumeDetailsArgsForCall[i].mask
}

func (fake *FakeClient) GetBlockVolumeDetailsReturns(result1 *datatypes.Network_Storage, result2 bool, result3 error) {
	fake.GetBlockVolumeDetailsStub = nil
	fake.getBlockVolumeDetailsReturns = struct {
		result1 *datatypes.Network_Storage
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetBlockVolumeDetailsReturnsOnCall(i int, result1 *datatypes.Network_Storage, result2 bool, result3 error) {
	fake.GetBlockVolumeDetailsStub = nil
	if fake.getBlockVolumeDetailsReturnsOnCall == nil {
		fake.getBlockVolumeDetailsReturnsOnCall = make(map[int]struct {
			result1 *datatypes.Network_Storage
			result2 bool
			result3 error
		})
	}
	fake.getBlockVolumeDetailsReturnsOnCall[i] = struct {
		result1 *datatypes.Network_Storage
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetBlockVolumeDetailsBySoftLayerAccount(volumeId int, mask string) (datatypes.Network_Storage, error) {
	fake.getBlockVolumeDetailsBySoftLayerAccountMutex.Lock()
	ret, specificReturn := fake.getBlockVolumeDetailsBySoftLayerAccountReturnsOnCall[len(fake.getBlockVolumeDetailsBySoftLayerAccountArgsForCall)]
	fake.getBlockVolumeDetailsBySoftLayerAccountArgsForCall = append(fake.getBlockVolumeDetailsBySoftLayerAccountArgsForCall, struct {
		volumeId int
		mask     string
	}{volumeId, mask})
	fake.recordInvocation("GetBlockVolumeDetailsBySoftLayerAccount", []interface{}{volumeId, mask})
	fake.getBlockVolumeDetailsBySoftLayerAccountMutex.Unlock()
	if fake.GetBlockVolumeDetailsBySoftLayerAccountStub != nil {
		return fake.GetBlockVolumeDetailsBySoftLayerAccountStub(volumeId, mask)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getBlockVolumeDetailsBySoftLayerAccountReturns.result1, fake.getBlockVolumeDetailsBySoftLayerAccountReturns.result2
}

func (fake *FakeClient) GetBlockVolumeDetailsBySoftLayerAccountCallCount() int {
	fake.getBlockVolumeDetailsBySoftLayerAccountMutex.RLock()
	defer fake.getBlockVolumeDetailsBySoftLayerAccountMutex.RUnlock()
	return len(fake.getBlockVolumeDetailsBySoftLayerAccountArgsForCall)
}

func (fake *FakeClient) GetBlockVolumeDetailsBySoftLayerAccountArgsForCall(i int) (int, string) {
	fake.getBlockVolumeDetailsBySoftLayerAccountMutex.RLock()
	defer fake.getBlockVolumeDetailsBySoftLayerAccountMutex.RUnlock()
	return fake.getBlockVolumeDetailsBySoftLayerAccountArgsForCall[i].volumeId, fake.getBlockVolumeDetailsBySoftLayerAccountArgsForCall[i].mask
}

func (fake *FakeClient) GetBlockVolumeDetailsBySoftLayerAccountReturns(result1 datatypes.Network_Storage, result2 error) {
	fake.GetBlockVolumeDetailsBySoftLayerAccountStub = nil
	fake.getBlockVolumeDetailsBySoftLayerAccountReturns = struct {
		result1 datatypes.Network_Storage
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetBlockVolumeDetailsBySoftLayerAccountReturnsOnCall(i int, result1 datatypes.Network_Storage, result2 error) {
	fake.GetBlockVolumeDetailsBySoftLayerAccountStub = nil
	if fake.getBlockVolumeDetailsBySoftLayerAccountReturnsOnCall == nil {
		fake.getBlockVolumeDetailsBySoftLayerAccountReturnsOnCall = make(map[int]struct {
			result1 datatypes.Network_Storage
			result2 error
		})
	}
	fake.getBlockVolumeDetailsBySoftLayerAccountReturnsOnCall[i] = struct {
		result1 datatypes.Network_Storage
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetNetworkStorageTarget(volumeId int, mask string) (string, bool, error) {
	fake.getNetworkStorageTargetMutex.Lock()
	ret, specificReturn := fake.getNetworkStorageTargetReturnsOnCall[len(fake.getNetworkStorageTargetArgsForCall)]
	fake.getNetworkStorageTargetArgsForCall = append(fake.getNetworkStorageTargetArgsForCall, struct {
		volumeId int
		mask     string
	}{volumeId, mask})
	fake.recordInvocation("GetNetworkStorageTarget", []interface{}{volumeId, mask})
	fake.getNetworkStorageTargetMutex.Unlock()
	if fake.GetNetworkStorageTargetStub != nil {
		return fake.GetNetworkStorageTargetStub(volumeId, mask)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.getNetworkStorageTargetReturns.result1, fake.getNetworkStorageTargetReturns.result2, fake.getNetworkStorageTargetReturns.result3
}

func (fake *FakeClient) GetNetworkStorageTargetCallCount() int {
	fake.getNetworkStorageTargetMutex.RLock()
	defer fake.getNetworkStorageTargetMutex.RUnlock()
	return len(fake.getNetworkStorageTargetArgsForCall)
}

func (fake *FakeClient) GetNetworkStorageTargetArgsForCall(i int) (int, string) {
	fake.getNetworkStorageTargetMutex.RLock()
	defer fake.getNetworkStorageTargetMutex.RUnlock()
	return fake.getNetworkStorageTargetArgsForCall[i].volumeId, fake.getNetworkStorageTargetArgsForCall[i].mask
}

func (fake *FakeClient) GetNetworkStorageTargetReturns(result1 string, result2 bool, result3 error) {
	fake.GetNetworkStorageTargetStub = nil
	fake.getNetworkStorageTargetReturns = struct {
		result1 string
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetNetworkStorageTargetReturnsOnCall(i int, result1 string, result2 bool, result3 error) {
	fake.GetNetworkStorageTargetStub = nil
	if fake.getNetworkStorageTargetReturnsOnCall == nil {
		fake.getNetworkStorageTargetReturnsOnCall = make(map[int]struct {
			result1 string
			result2 bool
			result3 error
		})
	}
	fake.getNetworkStorageTargetReturnsOnCall[i] = struct {
		result1 string
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) SetNotes(id int, notes string) (bool, error) {
	fake.setNotesMutex.Lock()
	ret, specificReturn := fake.setNotesReturnsOnCall[len(fake.setNotesArgsForCall)]
	fake.setNotesArgsForCall = append(fake.setNotesArgsForCall, struct {
		id    int
		notes string
	}{id, notes})
	fake.recordInvocation("SetNotes", []interface{}{id, notes})
	fake.setNotesMutex.Unlock()
	if fake.SetNotesStub != nil {
		return fake.SetNotesStub(id, notes)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.setNotesReturns.result1, fake.setNotesReturns.result2
}

func (fake *FakeClient) SetNotesCallCount() int {
	fake.setNotesMutex.RLock()
	defer fake.setNotesMutex.RUnlock()
	return len(fake.setNotesArgsForCall)
}

func (fake *FakeClient) SetNotesArgsForCall(i int) (int, string) {
	fake.setNotesMutex.RLock()
	defer fake.setNotesMutex.RUnlock()
	return fake.setNotesArgsForCall[i].id, fake.setNotesArgsForCall[i].notes
}

func (fake *FakeClient) SetNotesReturns(result1 bool, result2 error) {
	fake.SetNotesStub = nil
	fake.setNotesReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SetNotesReturnsOnCall(i int, result1 bool, result2 error) {
	fake.SetNotesStub = nil
	if fake.setNotesReturnsOnCall == nil {
		fake.setNotesReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.setNotesReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetImage(imageId int, mask string) (*datatypes.Virtual_Guest_Block_Device_Template_Group, bool, error) {
	fake.getImageMutex.Lock()
	ret, specificReturn := fake.getImageReturnsOnCall[len(fake.getImageArgsForCall)]
	fake.getImageArgsForCall = append(fake.getImageArgsForCall, struct {
		imageId int
		mask    string
	}{imageId, mask})
	fake.recordInvocation("GetImage", []interface{}{imageId, mask})
	fake.getImageMutex.Unlock()
	if fake.GetImageStub != nil {
		return fake.GetImageStub(imageId, mask)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.getImageReturns.result1, fake.getImageReturns.result2, fake.getImageReturns.result3
}

func (fake *FakeClient) GetImageCallCount() int {
	fake.getImageMutex.RLock()
	defer fake.getImageMutex.RUnlock()
	return len(fake.getImageArgsForCall)
}

func (fake *FakeClient) GetImageArgsForCall(i int) (int, string) {
	fake.getImageMutex.RLock()
	defer fake.getImageMutex.RUnlock()
	return fake.getImageArgsForCall[i].imageId, fake.getImageArgsForCall[i].mask
}

func (fake *FakeClient) GetImageReturns(result1 *datatypes.Virtual_Guest_Block_Device_Template_Group, result2 bool, result3 error) {
	fake.GetImageStub = nil
	fake.getImageReturns = struct {
		result1 *datatypes.Virtual_Guest_Block_Device_Template_Group
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetImageReturnsOnCall(i int, result1 *datatypes.Virtual_Guest_Block_Device_Template_Group, result2 bool, result3 error) {
	fake.GetImageStub = nil
	if fake.getImageReturnsOnCall == nil {
		fake.getImageReturnsOnCall = make(map[int]struct {
			result1 *datatypes.Virtual_Guest_Block_Device_Template_Group
			result2 bool
			result3 error
		})
	}
	fake.getImageReturnsOnCall[i] = struct {
		result1 *datatypes.Virtual_Guest_Block_Device_Template_Group
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetVlan(id int, mask string) (*datatypes.Network_Vlan, bool, error) {
	fake.getVlanMutex.Lock()
	ret, specificReturn := fake.getVlanReturnsOnCall[len(fake.getVlanArgsForCall)]
	fake.getVlanArgsForCall = append(fake.getVlanArgsForCall, struct {
		id   int
		mask string
	}{id, mask})
	fake.recordInvocation("GetVlan", []interface{}{id, mask})
	fake.getVlanMutex.Unlock()
	if fake.GetVlanStub != nil {
		return fake.GetVlanStub(id, mask)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.getVlanReturns.result1, fake.getVlanReturns.result2, fake.getVlanReturns.result3
}

func (fake *FakeClient) GetVlanCallCount() int {
	fake.getVlanMutex.RLock()
	defer fake.getVlanMutex.RUnlock()
	return len(fake.getVlanArgsForCall)
}

func (fake *FakeClient) GetVlanArgsForCall(i int) (int, string) {
	fake.getVlanMutex.RLock()
	defer fake.getVlanMutex.RUnlock()
	return fake.getVlanArgsForCall[i].id, fake.getVlanArgsForCall[i].mask
}

func (fake *FakeClient) GetVlanReturns(result1 *datatypes.Network_Vlan, result2 bool, result3 error) {
	fake.GetVlanStub = nil
	fake.getVlanReturns = struct {
		result1 *datatypes.Network_Vlan
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetVlanReturnsOnCall(i int, result1 *datatypes.Network_Vlan, result2 bool, result3 error) {
	fake.GetVlanStub = nil
	if fake.getVlanReturnsOnCall == nil {
		fake.getVlanReturnsOnCall = make(map[int]struct {
			result1 *datatypes.Network_Vlan
			result2 bool
			result3 error
		})
	}
	fake.getVlanReturnsOnCall[i] = struct {
		result1 *datatypes.Network_Vlan
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetSubnet(id int, mask string) (*datatypes.Network_Subnet, bool, error) {
	fake.getSubnetMutex.Lock()
	ret, specificReturn := fake.getSubnetReturnsOnCall[len(fake.getSubnetArgsForCall)]
	fake.getSubnetArgsForCall = append(fake.getSubnetArgsForCall, struct {
		id   int
		mask string
	}{id, mask})
	fake.recordInvocation("GetSubnet", []interface{}{id, mask})
	fake.getSubnetMutex.Unlock()
	if fake.GetSubnetStub != nil {
		return fake.GetSubnetStub(id, mask)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.getSubnetReturns.result1, fake.getSubnetReturns.result2, fake.getSubnetReturns.result3
}

func (fake *FakeClient) GetSubnetCallCount() int {
	fake.getSubnetMutex.RLock()
	defer fake.getSubnetMutex.RUnlock()
	return len(fake.getSubnetArgsForCall)
}

func (fake *FakeClient) GetSubnetArgsForCall(i int) (int, string) {
	fake.getSubnetMutex.RLock()
	defer fake.getSubnetMutex.RUnlock()
	return fake.getSubnetArgsForCall[i].id, fake.getSubnetArgsForCall[i].mask
}

func (fake *FakeClient) GetSubnetReturns(result1 *datatypes.Network_Subnet, result2 bool, result3 error) {
	fake.GetSubnetStub = nil
	fake.getSubnetReturns = struct {
		result1 *datatypes.Network_Subnet
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetSubnetReturnsOnCall(i int, result1 *datatypes.Network_Subnet, result2 bool, result3 error) {
	fake.GetSubnetStub = nil
	if fake.getSubnetReturnsOnCall == nil {
		fake.getSubnetReturnsOnCall = make(map[int]struct {
			result1 *datatypes.Network_Subnet
			result2 bool
			result3 error
		})
	}
	fake.getSubnetReturnsOnCall[i] = struct {
		result1 *datatypes.Network_Subnet
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetAllowedHostCredential(id int) (*datatypes.Network_Storage_Allowed_Host, bool, error) {
	fake.getAllowedHostCredentialMutex.Lock()
	ret, specificReturn := fake.getAllowedHostCredentialReturnsOnCall[len(fake.getAllowedHostCredentialArgsForCall)]
	fake.getAllowedHostCredentialArgsForCall = append(fake.getAllowedHostCredentialArgsForCall, struct {
		id int
	}{id})
	fake.recordInvocation("GetAllowedHostCredential", []interface{}{id})
	fake.getAllowedHostCredentialMutex.Unlock()
	if fake.GetAllowedHostCredentialStub != nil {
		return fake.GetAllowedHostCredentialStub(id)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.getAllowedHostCredentialReturns.result1, fake.getAllowedHostCredentialReturns.result2, fake.getAllowedHostCredentialReturns.result3
}

func (fake *FakeClient) GetAllowedHostCredentialCallCount() int {
	fake.getAllowedHostCredentialMutex.RLock()
	defer fake.getAllowedHostCredentialMutex.RUnlock()
	return len(fake.getAllowedHostCredentialArgsForCall)
}

func (fake *FakeClient) GetAllowedHostCredentialArgsForCall(i int) int {
	fake.getAllowedHostCredentialMutex.RLock()
	defer fake.getAllowedHostCredentialMutex.RUnlock()
	return fake.getAllowedHostCredentialArgsForCall[i].id
}

func (fake *FakeClient) GetAllowedHostCredentialReturns(result1 *datatypes.Network_Storage_Allowed_Host, result2 bool, result3 error) {
	fake.GetAllowedHostCredentialStub = nil
	fake.getAllowedHostCredentialReturns = struct {
		result1 *datatypes.Network_Storage_Allowed_Host
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetAllowedHostCredentialReturnsOnCall(i int, result1 *datatypes.Network_Storage_Allowed_Host, result2 bool, result3 error) {
	fake.GetAllowedHostCredentialStub = nil
	if fake.getAllowedHostCredentialReturnsOnCall == nil {
		fake.getAllowedHostCredentialReturnsOnCall = make(map[int]struct {
			result1 *datatypes.Network_Storage_Allowed_Host
			result2 bool
			result3 error
		})
	}
	fake.getAllowedHostCredentialReturnsOnCall[i] = struct {
		result1 *datatypes.Network_Storage_Allowed_Host
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetAllowedNetworkStorage(id int) ([]string, bool, error) {
	fake.getAllowedNetworkStorageMutex.Lock()
	ret, specificReturn := fake.getAllowedNetworkStorageReturnsOnCall[len(fake.getAllowedNetworkStorageArgsForCall)]
	fake.getAllowedNetworkStorageArgsForCall = append(fake.getAllowedNetworkStorageArgsForCall, struct {
		id int
	}{id})
	fake.recordInvocation("GetAllowedNetworkStorage", []interface{}{id})
	fake.getAllowedNetworkStorageMutex.Unlock()
	if fake.GetAllowedNetworkStorageStub != nil {
		return fake.GetAllowedNetworkStorageStub(id)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.getAllowedNetworkStorageReturns.result1, fake.getAllowedNetworkStorageReturns.result2, fake.getAllowedNetworkStorageReturns.result3
}

func (fake *FakeClient) GetAllowedNetworkStorageCallCount() int {
	fake.getAllowedNetworkStorageMutex.RLock()
	defer fake.getAllowedNetworkStorageMutex.RUnlock()
	return len(fake.getAllowedNetworkStorageArgsForCall)
}

func (fake *FakeClient) GetAllowedNetworkStorageArgsForCall(i int) int {
	fake.getAllowedNetworkStorageMutex.RLock()
	defer fake.getAllowedNetworkStorageMutex.RUnlock()
	return fake.getAllowedNetworkStorageArgsForCall[i].id
}

func (fake *FakeClient) GetAllowedNetworkStorageReturns(result1 []string, result2 bool, result3 error) {
	fake.GetAllowedNetworkStorageStub = nil
	fake.getAllowedNetworkStorageReturns = struct {
		result1 []string
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) GetAllowedNetworkStorageReturnsOnCall(i int, result1 []string, result2 bool, result3 error) {
	fake.GetAllowedNetworkStorageStub = nil
	if fake.getAllowedNetworkStorageReturnsOnCall == nil {
		fake.getAllowedNetworkStorageReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 bool
			result3 error
		})
	}
	fake.getAllowedNetworkStorageReturnsOnCall[i] = struct {
		result1 []string
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) CreateSshKey(label *string, key *string, fingerPrint *string) (*datatypes.Security_Ssh_Key, error) {
	fake.createSshKeyMutex.Lock()
	ret, specificReturn := fake.createSshKeyReturnsOnCall[len(fake.createSshKeyArgsForCall)]
	fake.createSshKeyArgsForCall = append(fake.createSshKeyArgsForCall, struct {
		label       *string
		key         *string
		fingerPrint *string
	}{label, key, fingerPrint})
	fake.recordInvocation("CreateSshKey", []interface{}{label, key, fingerPrint})
	fake.createSshKeyMutex.Unlock()
	if fake.CreateSshKeyStub != nil {
		return fake.CreateSshKeyStub(label, key, fingerPrint)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createSshKeyReturns.result1, fake.createSshKeyReturns.result2
}

func (fake *FakeClient) CreateSshKeyCallCount() int {
	fake.createSshKeyMutex.RLock()
	defer fake.createSshKeyMutex.RUnlock()
	return len(fake.createSshKeyArgsForCall)
}

func (fake *FakeClient) CreateSshKeyArgsForCall(i int) (*string, *string, *string) {
	fake.createSshKeyMutex.RLock()
	defer fake.createSshKeyMutex.RUnlock()
	return fake.createSshKeyArgsForCall[i].label, fake.createSshKeyArgsForCall[i].key, fake.createSshKeyArgsForCall[i].fingerPrint
}

func (fake *FakeClient) CreateSshKeyReturns(result1 *datatypes.Security_Ssh_Key, result2 error) {
	fake.CreateSshKeyStub = nil
	fake.createSshKeyReturns = struct {
		result1 *datatypes.Security_Ssh_Key
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateSshKeyReturnsOnCall(i int, result1 *datatypes.Security_Ssh_Key, result2 error) {
	fake.CreateSshKeyStub = nil
	if fake.createSshKeyReturnsOnCall == nil {
		fake.createSshKeyReturnsOnCall = make(map[int]struct {
			result1 *datatypes.Security_Ssh_Key
			result2 error
		})
	}
	fake.createSshKeyReturnsOnCall[i] = struct {
		result1 *datatypes.Security_Ssh_Key
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DeleteSshKey(id int) (bool, error) {
	fake.deleteSshKeyMutex.Lock()
	ret, specificReturn := fake.deleteSshKeyReturnsOnCall[len(fake.deleteSshKeyArgsForCall)]
	fake.deleteSshKeyArgsForCall = append(fake.deleteSshKeyArgsForCall, struct {
		id int
	}{id})
	fake.recordInvocation("DeleteSshKey", []interface{}{id})
	fake.deleteSshKeyMutex.Unlock()
	if fake.DeleteSshKeyStub != nil {
		return fake.DeleteSshKeyStub(id)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.deleteSshKeyReturns.result1, fake.deleteSshKeyReturns.result2
}

func (fake *FakeClient) DeleteSshKeyCallCount() int {
	fake.deleteSshKeyMutex.RLock()
	defer fake.deleteSshKeyMutex.RUnlock()
	return len(fake.deleteSshKeyArgsForCall)
}

func (fake *FakeClient) DeleteSshKeyArgsForCall(i int) int {
	fake.deleteSshKeyMutex.RLock()
	defer fake.deleteSshKeyMutex.RUnlock()
	return fake.deleteSshKeyArgsForCall[i].id
}

func (fake *FakeClient) DeleteSshKeyReturns(result1 bool, result2 error) {
	fake.DeleteSshKeyStub = nil
	fake.deleteSshKeyReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DeleteSshKeyReturnsOnCall(i int, result1 bool, result2 error) {
	fake.DeleteSshKeyStub = nil
	if fake.deleteSshKeyReturnsOnCall == nil {
		fake.deleteSshKeyReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.deleteSshKeyReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateInstanceFromVPS(template *datatypes.Virtual_Guest, stemcellID int, sshKeys []int) (*datatypes.Virtual_Guest, error) {
	var sshKeysCopy []int
	if sshKeys != nil {
		sshKeysCopy = make([]int, len(sshKeys))
		copy(sshKeysCopy, sshKeys)
	}
	fake.createInstanceFromVPSMutex.Lock()
	ret, specificReturn := fake.createInstanceFromVPSReturnsOnCall[len(fake.createInstanceFromVPSArgsForCall)]
	fake.createInstanceFromVPSArgsForCall = append(fake.createInstanceFromVPSArgsForCall, struct {
		template   *datatypes.Virtual_Guest
		stemcellID int
		sshKeys    []int
	}{template, stemcellID, sshKeysCopy})
	fake.recordInvocation("CreateInstanceFromVPS", []interface{}{template, stemcellID, sshKeysCopy})
	fake.createInstanceFromVPSMutex.Unlock()
	if fake.CreateInstanceFromVPSStub != nil {
		return fake.CreateInstanceFromVPSStub(template, stemcellID, sshKeys)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createInstanceFromVPSReturns.result1, fake.createInstanceFromVPSReturns.result2
}

func (fake *FakeClient) CreateInstanceFromVPSCallCount() int {
	fake.createInstanceFromVPSMutex.RLock()
	defer fake.createInstanceFromVPSMutex.RUnlock()
	return len(fake.createInstanceFromVPSArgsForCall)
}

func (fake *FakeClient) CreateInstanceFromVPSArgsForCall(i int) (*datatypes.Virtual_Guest, int, []int) {
	fake.createInstanceFromVPSMutex.RLock()
	defer fake.createInstanceFromVPSMutex.RUnlock()
	return fake.createInstanceFromVPSArgsForCall[i].template, fake.createInstanceFromVPSArgsForCall[i].stemcellID, fake.createInstanceFromVPSArgsForCall[i].sshKeys
}

func (fake *FakeClient) CreateInstanceFromVPSReturns(result1 *datatypes.Virtual_Guest, result2 error) {
	fake.CreateInstanceFromVPSStub = nil
	fake.createInstanceFromVPSReturns = struct {
		result1 *datatypes.Virtual_Guest
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateInstanceFromVPSReturnsOnCall(i int, result1 *datatypes.Virtual_Guest, result2 error) {
	fake.CreateInstanceFromVPSStub = nil
	if fake.createInstanceFromVPSReturnsOnCall == nil {
		fake.createInstanceFromVPSReturnsOnCall = make(map[int]struct {
			result1 *datatypes.Virtual_Guest
			result2 error
		})
	}
	fake.createInstanceFromVPSReturnsOnCall[i] = struct {
		result1 *datatypes.Virtual_Guest
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DeleteInstanceFromVPS(id int) error {
	fake.deleteInstanceFromVPSMutex.Lock()
	ret, specificReturn := fake.deleteInstanceFromVPSReturnsOnCall[len(fake.deleteInstanceFromVPSArgsForCall)]
	fake.deleteInstanceFromVPSArgsForCall = append(fake.deleteInstanceFromVPSArgsForCall, struct {
		id int
	}{id})
	fake.recordInvocation("DeleteInstanceFromVPS", []interface{}{id})
	fake.deleteInstanceFromVPSMutex.Unlock()
	if fake.DeleteInstanceFromVPSStub != nil {
		return fake.DeleteInstanceFromVPSStub(id)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteInstanceFromVPSReturns.result1
}

func (fake *FakeClient) DeleteInstanceFromVPSCallCount() int {
	fake.deleteInstanceFromVPSMutex.RLock()
	defer fake.deleteInstanceFromVPSMutex.RUnlock()
	return len(fake.deleteInstanceFromVPSArgsForCall)
}

func (fake *FakeClient) DeleteInstanceFromVPSArgsForCall(i int) int {
	fake.deleteInstanceFromVPSMutex.RLock()
	defer fake.deleteInstanceFromVPSMutex.RUnlock()
	return fake.deleteInstanceFromVPSArgsForCall[i].id
}

func (fake *FakeClient) DeleteInstanceFromVPSReturns(result1 error) {
	fake.DeleteInstanceFromVPSStub = nil
	fake.deleteInstanceFromVPSReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeleteInstanceFromVPSReturnsOnCall(i int, result1 error) {
	fake.DeleteInstanceFromVPSStub = nil
	if fake.deleteInstanceFromVPSReturnsOnCall == nil {
		fake.deleteInstanceFromVPSReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteInstanceFromVPSReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) CreateSnapshot(volumeId int, notes string) (datatypes.Network_Storage, error) {
	fake.createSnapshotMutex.Lock()
	ret, specificReturn := fake.createSnapshotReturnsOnCall[len(fake.createSnapshotArgsForCall)]
	fake.createSnapshotArgsForCall = append(fake.createSnapshotArgsForCall, struct {
		volumeId int
		notes    string
	}{volumeId, notes})
	fake.recordInvocation("CreateSnapshot", []interface{}{volumeId, notes})
	fake.createSnapshotMutex.Unlock()
	if fake.CreateSnapshotStub != nil {
		return fake.CreateSnapshotStub(volumeId, notes)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createSnapshotReturns.result1, fake.createSnapshotReturns.result2
}

func (fake *FakeClient) CreateSnapshotCallCount() int {
	fake.createSnapshotMutex.RLock()
	defer fake.createSnapshotMutex.RUnlock()
	return len(fake.createSnapshotArgsForCall)
}

func (fake *FakeClient) CreateSnapshotArgsForCall(i int) (int, string) {
	fake.createSnapshotMutex.RLock()
	defer fake.createSnapshotMutex.RUnlock()
	return fake.createSnapshotArgsForCall[i].volumeId, fake.createSnapshotArgsForCall[i].notes
}

func (fake *FakeClient) CreateSnapshotReturns(result1 datatypes.Network_Storage, result2 error) {
	fake.CreateSnapshotStub = nil
	fake.createSnapshotReturns = struct {
		result1 datatypes.Network_Storage
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateSnapshotReturnsOnCall(i int, result1 datatypes.Network_Storage, result2 error) {
	fake.CreateSnapshotStub = nil
	if fake.createSnapshotReturnsOnCall == nil {
		fake.createSnapshotReturnsOnCall = make(map[int]struct {
			result1 datatypes.Network_Storage
			result2 error
		})
	}
	fake.createSnapshotReturnsOnCall[i] = struct {
		result1 datatypes.Network_Storage
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DeleteSnapshot(snapshotId int) error {
	fake.deleteSnapshotMutex.Lock()
	ret, specificReturn := fake.deleteSnapshotReturnsOnCall[len(fake.deleteSnapshotArgsForCall)]
	fake.deleteSnapshotArgsForCall = append(fake.deleteSnapshotArgsForCall, struct {
		snapshotId int
	}{snapshotId})
	fake.recordInvocation("DeleteSnapshot", []interface{}{snapshotId})
	fake.deleteSnapshotMutex.Unlock()
	if fake.DeleteSnapshotStub != nil {
		return fake.DeleteSnapshotStub(snapshotId)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteSnapshotReturns.result1
}

func (fake *FakeClient) DeleteSnapshotCallCount() int {
	fake.deleteSnapshotMutex.RLock()
	defer fake.deleteSnapshotMutex.RUnlock()
	return len(fake.deleteSnapshotArgsForCall)
}

func (fake *FakeClient) DeleteSnapshotArgsForCall(i int) int {
	fake.deleteSnapshotMutex.RLock()
	defer fake.deleteSnapshotMutex.RUnlock()
	return fake.deleteSnapshotArgsForCall[i].snapshotId
}

func (fake *FakeClient) DeleteSnapshotReturns(result1 error) {
	fake.DeleteSnapshotStub = nil
	fake.deleteSnapshotReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeleteSnapshotReturnsOnCall(i int, result1 error) {
	fake.DeleteSnapshotStub = nil
	if fake.deleteSnapshotReturnsOnCall == nil {
		fake.deleteSnapshotReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteSnapshotReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) CreateTicket(ticketSubject *string, ticketTitle *string, contents *string, attachmentId *int, attachmentType *string) error {
	fake.createTicketMutex.Lock()
	ret, specificReturn := fake.createTicketReturnsOnCall[len(fake.createTicketArgsForCall)]
	fake.createTicketArgsForCall = append(fake.createTicketArgsForCall, struct {
		ticketSubject  *string
		ticketTitle    *string
		contents       *string
		attachmentId   *int
		attachmentType *string
	}{ticketSubject, ticketTitle, contents, attachmentId, attachmentType})
	fake.recordInvocation("CreateTicket", []interface{}{ticketSubject, ticketTitle, contents, attachmentId, attachmentType})
	fake.createTicketMutex.Unlock()
	if fake.CreateTicketStub != nil {
		return fake.CreateTicketStub(ticketSubject, ticketTitle, contents, attachmentId, attachmentType)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.createTicketReturns.result1
}

func (fake *FakeClient) CreateTicketCallCount() int {
	fake.createTicketMutex.RLock()
	defer fake.createTicketMutex.RUnlock()
	return len(fake.createTicketArgsForCall)
}

func (fake *FakeClient) CreateTicketArgsForCall(i int) (*string, *string, *string, *int, *string) {
	fake.createTicketMutex.RLock()
	defer fake.createTicketMutex.RUnlock()
	return fake.createTicketArgsForCall[i].ticketSubject, fake.createTicketArgsForCall[i].ticketTitle, fake.createTicketArgsForCall[i].contents, fake.createTicketArgsForCall[i].attachmentId, fake.createTicketArgsForCall[i].attachmentType
}

func (fake *FakeClient) CreateTicketReturns(result1 error) {
	fake.CreateTicketStub = nil
	fake.createTicketReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) CreateTicketReturnsOnCall(i int, result1 error) {
	fake.CreateTicketStub = nil
	if fake.createTicketReturnsOnCall == nil {
		fake.createTicketReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createTicketReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) CreateSwiftContainer(containerName string) error {
	fake.createSwiftContainerMutex.Lock()
	ret, specificReturn := fake.createSwiftContainerReturnsOnCall[len(fake.createSwiftContainerArgsForCall)]
	fake.createSwiftContainerArgsForCall = append(fake.createSwiftContainerArgsForCall, struct {
		containerName string
	}{containerName})
	fake.recordInvocation("CreateSwiftContainer", []interface{}{containerName})
	fake.createSwiftContainerMutex.Unlock()
	if fake.CreateSwiftContainerStub != nil {
		return fake.CreateSwiftContainerStub(containerName)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.createSwiftContainerReturns.result1
}

func (fake *FakeClient) CreateSwiftContainerCallCount() int {
	fake.createSwiftContainerMutex.RLock()
	defer fake.createSwiftContainerMutex.RUnlock()
	return len(fake.createSwiftContainerArgsForCall)
}

func (fake *FakeClient) CreateSwiftContainerArgsForCall(i int) string {
	fake.createSwiftContainerMutex.RLock()
	defer fake.createSwiftContainerMutex.RUnlock()
	return fake.createSwiftContainerArgsForCall[i].containerName
}

func (fake *FakeClient) CreateSwiftContainerReturns(result1 error) {
	fake.CreateSwiftContainerStub = nil
	fake.createSwiftContainerReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) CreateSwiftContainerReturnsOnCall(i int, result1 error) {
	fake.CreateSwiftContainerStub = nil
	if fake.createSwiftContainerReturnsOnCall == nil {
		fake.createSwiftContainerReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createSwiftContainerReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeleteSwiftContainer(containerName string) error {
	fake.deleteSwiftContainerMutex.Lock()
	ret, specificReturn := fake.deleteSwiftContainerReturnsOnCall[len(fake.deleteSwiftContainerArgsForCall)]
	fake.deleteSwiftContainerArgsForCall = append(fake.deleteSwiftContainerArgsForCall, struct {
		containerName string
	}{containerName})
	fake.recordInvocation("DeleteSwiftContainer", []interface{}{containerName})
	fake.deleteSwiftContainerMutex.Unlock()
	if fake.DeleteSwiftContainerStub != nil {
		return fake.DeleteSwiftContainerStub(containerName)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteSwiftContainerReturns.result1
}

func (fake *FakeClient) DeleteSwiftContainerCallCount() int {
	fake.deleteSwiftContainerMutex.RLock()
	defer fake.deleteSwiftContainerMutex.RUnlock()
	return len(fake.deleteSwiftContainerArgsForCall)
}

func (fake *FakeClient) DeleteSwiftContainerArgsForCall(i int) string {
	fake.deleteSwiftContainerMutex.RLock()
	defer fake.deleteSwiftContainerMutex.RUnlock()
	return fake.deleteSwiftContainerArgsForCall[i].containerName
}

func (fake *FakeClient) DeleteSwiftContainerReturns(result1 error) {
	fake.DeleteSwiftContainerStub = nil
	fake.deleteSwiftContainerReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeleteSwiftContainerReturnsOnCall(i int, result1 error) {
	fake.DeleteSwiftContainerStub = nil
	if fake.deleteSwiftContainerReturnsOnCall == nil {
		fake.deleteSwiftContainerReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteSwiftContainerReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) UploadSwiftLargeObject(containerName string, objectName string, objectFile string) error {
	fake.uploadSwiftLargeObjectMutex.Lock()
	ret, specificReturn := fake.uploadSwiftLargeObjectReturnsOnCall[len(fake.uploadSwiftLargeObjectArgsForCall)]
	fake.uploadSwiftLargeObjectArgsForCall = append(fake.uploadSwiftLargeObjectArgsForCall, struct {
		containerName string
		objectName    string
		objectFile    string
	}{containerName, objectName, objectFile})
	fake.recordInvocation("UploadSwiftLargeObject", []interface{}{containerName, objectName, objectFile})
	fake.uploadSwiftLargeObjectMutex.Unlock()
	if fake.UploadSwiftLargeObjectStub != nil {
		return fake.UploadSwiftLargeObjectStub(containerName, objectName, objectFile)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.uploadSwiftLargeObjectReturns.result1
}

func (fake *FakeClient) UploadSwiftLargeObjectCallCount() int {
	fake.uploadSwiftLargeObjectMutex.RLock()
	defer fake.uploadSwiftLargeObjectMutex.RUnlock()
	return len(fake.uploadSwiftLargeObjectArgsForCall)
}

func (fake *FakeClient) UploadSwiftLargeObjectArgsForCall(i int) (string, string, string) {
	fake.uploadSwiftLargeObjectMutex.RLock()
	defer fake.uploadSwiftLargeObjectMutex.RUnlock()
	return fake.uploadSwiftLargeObjectArgsForCall[i].containerName, fake.uploadSwiftLargeObjectArgsForCall[i].objectName, fake.uploadSwiftLargeObjectArgsForCall[i].objectFile
}

func (fake *FakeClient) UploadSwiftLargeObjectReturns(result1 error) {
	fake.UploadSwiftLargeObjectStub = nil
	fake.uploadSwiftLargeObjectReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) UploadSwiftLargeObjectReturnsOnCall(i int, result1 error) {
	fake.UploadSwiftLargeObjectStub = nil
	if fake.uploadSwiftLargeObjectReturnsOnCall == nil {
		fake.uploadSwiftLargeObjectReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.uploadSwiftLargeObjectReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeleteSwiftLargeObject(containerName string, objectFileName string) error {
	fake.deleteSwiftLargeObjectMutex.Lock()
	ret, specificReturn := fake.deleteSwiftLargeObjectReturnsOnCall[len(fake.deleteSwiftLargeObjectArgsForCall)]
	fake.deleteSwiftLargeObjectArgsForCall = append(fake.deleteSwiftLargeObjectArgsForCall, struct {
		containerName  string
		objectFileName string
	}{containerName, objectFileName})
	fake.recordInvocation("DeleteSwiftLargeObject", []interface{}{containerName, objectFileName})
	fake.deleteSwiftLargeObjectMutex.Unlock()
	if fake.DeleteSwiftLargeObjectStub != nil {
		return fake.DeleteSwiftLargeObjectStub(containerName, objectFileName)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteSwiftLargeObjectReturns.result1
}

func (fake *FakeClient) DeleteSwiftLargeObjectCallCount() int {
	fake.deleteSwiftLargeObjectMutex.RLock()
	defer fake.deleteSwiftLargeObjectMutex.RUnlock()
	return len(fake.deleteSwiftLargeObjectArgsForCall)
}

func (fake *FakeClient) DeleteSwiftLargeObjectArgsForCall(i int) (string, string) {
	fake.deleteSwiftLargeObjectMutex.RLock()
	defer fake.deleteSwiftLargeObjectMutex.RUnlock()
	return fake.deleteSwiftLargeObjectArgsForCall[i].containerName, fake.deleteSwiftLargeObjectArgsForCall[i].objectFileName
}

func (fake *FakeClient) DeleteSwiftLargeObjectReturns(result1 error) {
	fake.DeleteSwiftLargeObjectStub = nil
	fake.deleteSwiftLargeObjectReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeleteSwiftLargeObjectReturnsOnCall(i int, result1 error) {
	fake.DeleteSwiftLargeObjectStub = nil
	if fake.deleteSwiftLargeObjectReturnsOnCall == nil {
		fake.deleteSwiftLargeObjectReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteSwiftLargeObjectReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) CreateImageFromExternalSource(imageName string, note string, cluster string, osCode string) (int, error) {
	fake.createImageFromExternalSourceMutex.Lock()
	ret, specificReturn := fake.createImageFromExternalSourceReturnsOnCall[len(fake.createImageFromExternalSourceArgsForCall)]
	fake.createImageFromExternalSourceArgsForCall = append(fake.createImageFromExternalSourceArgsForCall, struct {
		imageName string
		note      string
		cluster   string
		osCode    string
	}{imageName, note, cluster, osCode})
	fake.recordInvocation("CreateImageFromExternalSource", []interface{}{imageName, note, cluster, osCode})
	fake.createImageFromExternalSourceMutex.Unlock()
	if fake.CreateImageFromExternalSourceStub != nil {
		return fake.CreateImageFromExternalSourceStub(imageName, note, cluster, osCode)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createImageFromExternalSourceReturns.result1, fake.createImageFromExternalSourceReturns.result2
}

func (fake *FakeClient) CreateImageFromExternalSourceCallCount() int {
	fake.createImageFromExternalSourceMutex.RLock()
	defer fake.createImageFromExternalSourceMutex.RUnlock()
	return len(fake.createImageFromExternalSourceArgsForCall)
}

func (fake *FakeClient) CreateImageFromExternalSourceArgsForCall(i int) (string, string, string, string) {
	fake.createImageFromExternalSourceMutex.RLock()
	defer fake.createImageFromExternalSourceMutex.RUnlock()
	return fake.createImageFromExternalSourceArgsForCall[i].imageName, fake.createImageFromExternalSourceArgsForCall[i].note, fake.createImageFromExternalSourceArgsForCall[i].cluster, fake.createImageFromExternalSourceArgsForCall[i].osCode
}

func (fake *FakeClient) CreateImageFromExternalSourceReturns(result1 int, result2 error) {
	fake.CreateImageFromExternalSourceStub = nil
	fake.createImageFromExternalSourceReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateImageFromExternalSourceReturnsOnCall(i int, result1 int, result2 error) {
	fake.CreateImageFromExternalSourceStub = nil
	if fake.createImageFromExternalSourceReturnsOnCall == nil {
		fake.createImageFromExternalSourceReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.createImageFromExternalSourceReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.cancelInstanceMutex.RLock()
	defer fake.cancelInstanceMutex.RUnlock()
	fake.createInstanceMutex.RLock()
	defer fake.createInstanceMutex.RUnlock()
	fake.editInstanceMutex.RLock()
	defer fake.editInstanceMutex.RUnlock()
	fake.getInstanceMutex.RLock()
	defer fake.getInstanceMutex.RUnlock()
	fake.getInstanceByPrimaryBackendIpAddressMutex.RLock()
	defer fake.getInstanceByPrimaryBackendIpAddressMutex.RUnlock()
	fake.getInstanceByPrimaryIpAddressMutex.RLock()
	defer fake.getInstanceByPrimaryIpAddressMutex.RUnlock()
	fake.rebootInstanceMutex.RLock()
	defer fake.rebootInstanceMutex.RUnlock()
	fake.reloadInstanceMutex.RLock()
	defer fake.reloadInstanceMutex.RUnlock()
	fake.upgradeInstanceConfigMutex.RLock()
	defer fake.upgradeInstanceConfigMutex.RUnlock()
	fake.upgradeInstanceMutex.RLock()
	defer fake.upgradeInstanceMutex.RUnlock()
	fake.waitInstanceUntilReadyMutex.RLock()
	defer fake.waitInstanceUntilReadyMutex.RUnlock()
	fake.waitInstanceUntilReadyWithTicketMutex.RLock()
	defer fake.waitInstanceUntilReadyWithTicketMutex.RUnlock()
	fake.waitInstanceHasActiveTransactionMutex.RLock()
	defer fake.waitInstanceHasActiveTransactionMutex.RUnlock()
	fake.waitInstanceHasNoneActiveTransactionMutex.RLock()
	defer fake.waitInstanceHasNoneActiveTransactionMutex.RUnlock()
	fake.waitVolumeProvisioningWithOrderIdMutex.RLock()
	defer fake.waitVolumeProvisioningWithOrderIdMutex.RUnlock()
	fake.setTagsMutex.RLock()
	defer fake.setTagsMutex.RUnlock()
	fake.setInstanceMetadataMutex.RLock()
	defer fake.setInstanceMetadataMutex.RUnlock()
	fake.attachSecondDiskToInstanceMutex.RLock()
	defer fake.attachSecondDiskToInstanceMutex.RUnlock()
	fake.getInstanceAllowedHostMutex.RLock()
	defer fake.getInstanceAllowedHostMutex.RUnlock()
	fake.authorizeHostToVolumeMutex.RLock()
	defer fake.authorizeHostToVolumeMutex.RUnlock()
	fake.deauthorizeHostToVolumeMutex.RLock()
	defer fake.deauthorizeHostToVolumeMutex.RUnlock()
	fake.createVolumeMutex.RLock()
	defer fake.createVolumeMutex.RUnlock()
	fake.orderBlockVolumeMutex.RLock()
	defer fake.orderBlockVolumeMutex.RUnlock()
	fake.orderBlockVolume2Mutex.RLock()
	defer fake.orderBlockVolume2Mutex.RUnlock()
	fake.cancelBlockVolumeMutex.RLock()
	defer fake.cancelBlockVolumeMutex.RUnlock()
	fake.getBlockVolumeDetailsMutex.RLock()
	defer fake.getBlockVolumeDetailsMutex.RUnlock()
	fake.getBlockVolumeDetailsBySoftLayerAccountMutex.RLock()
	defer fake.getBlockVolumeDetailsBySoftLayerAccountMutex.RUnlock()
	fake.getNetworkStorageTargetMutex.RLock()
	defer fake.getNetworkStorageTargetMutex.RUnlock()
	fake.setNotesMutex.RLock()
	defer fake.setNotesMutex.RUnlock()
	fake.getImageMutex.RLock()
	defer fake.getImageMutex.RUnlock()
	fake.getVlanMutex.RLock()
	defer fake.getVlanMutex.RUnlock()
	fake.getSubnetMutex.RLock()
	defer fake.getSubnetMutex.RUnlock()
	fake.getAllowedHostCredentialMutex.RLock()
	defer fake.getAllowedHostCredentialMutex.RUnlock()
	fake.getAllowedNetworkStorageMutex.RLock()
	defer fake.getAllowedNetworkStorageMutex.RUnlock()
	fake.createSshKeyMutex.RLock()
	defer fake.createSshKeyMutex.RUnlock()
	fake.deleteSshKeyMutex.RLock()
	defer fake.deleteSshKeyMutex.RUnlock()
	fake.createInstanceFromVPSMutex.RLock()
	defer fake.createInstanceFromVPSMutex.RUnlock()
	fake.deleteInstanceFromVPSMutex.RLock()
	defer fake.deleteInstanceFromVPSMutex.RUnlock()
	fake.createSnapshotMutex.RLock()
	defer fake.createSnapshotMutex.RUnlock()
	fake.deleteSnapshotMutex.RLock()
	defer fake.deleteSnapshotMutex.RUnlock()
	fake.createTicketMutex.RLock()
	defer fake.createTicketMutex.RUnlock()
	fake.createSwiftContainerMutex.RLock()
	defer fake.createSwiftContainerMutex.RUnlock()
	fake.deleteSwiftContainerMutex.RLock()
	defer fake.deleteSwiftContainerMutex.RUnlock()
	fake.uploadSwiftLargeObjectMutex.RLock()
	defer fake.uploadSwiftLargeObjectMutex.RUnlock()
	fake.deleteSwiftLargeObjectMutex.RLock()
	defer fake.deleteSwiftLargeObjectMutex.RUnlock()
	fake.createImageFromExternalSourceMutex.RLock()
	defer fake.createImageFromExternalSourceMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ client.Client = new(FakeClient)
